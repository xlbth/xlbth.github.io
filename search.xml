<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo使用教程</title>
    <url>/posts/42bd.html</url>
    <content><![CDATA[<h1 id="HEXO快捷指令"><a href="#HEXO快捷指令" class="headerlink" title="HEXO快捷指令"></a>HEXO快捷指令</h1><h3 id="创建新blog命令"><a href="#创建新blog命令" class="headerlink" title="创建新blog命令#"></a>创建新blog命令#</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n 博客名字</span><br></pre></td></tr></table></figure>

<h3 id="打开博客文档"><a href="#打开博客文档" class="headerlink" title="打开博客文档"></a>打开博客文档</h3><p>编辑文档</p>
<p><code> &lt;!--more--&gt;以下部分隐藏</code> </p>
<p>……</p>
<p>保存文档</p>
<h3 id="提交文档"><a href="#提交文档" class="headerlink" title="提交文档"></a>提交文档</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<span id="more"></span>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>/posts/cc59.html</url>
    <content><![CDATA[<h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><p><strong>阶段 1：入门</strong></p>
<ul>
<li>了解TypeScript的基本概念和语法</li>
<li>学习如何声明变量、函数和类</li>
<li>理解静态类型和类型注解的概念</li>
</ul>
<p><strong>阶段 2：类型系统</strong></p>
<ul>
<li>深入了解TypeScript的类型系统，包括原始类型、数组、元组、枚举等</li>
<li>学习如何定义和使用接口和类型别名</li>
<li>探索泛型的概念和用法</li>
</ul>
<p><strong>阶段 3：高级特性</strong></p>
<ul>
<li>学习TypeScript中的模块化和命名空间</li>
<li>理解装饰器的作用和使用方式</li>
<li>探索异步编程和Promise、async&#x2F;await等特性</li>
</ul>
<p><strong>阶段 4：与JavaScript的互操作性</strong></p>
<ul>
<li>学习如何使用TypeScript与现有的JavaScript库和框架进行交互</li>
<li>理解类型声明文件和如何使用它们扩展JavaScript库的类型信息</li>
</ul>
<p><strong>阶段 5：实际应用</strong></p>
<ul>
<li>探索如何在实际项目中使用TypeScript</li>
<li>学习调试和构建TypeScript应用程序的技巧</li>
<li>了解TypeScript在大型项目和团队中的最佳实践</li>
</ul>
<span id="more"></span>

<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="一、TypeScript的基本概念和语法"><a href="#一、TypeScript的基本概念和语法" class="headerlink" title="一、TypeScript的基本概念和语法"></a>一、TypeScript的基本概念和语法</h2><p>以下是一些重要的概念和语法要点：</p>
<h3 id="1-静态类型"><a href="#1-静态类型" class="headerlink" title="1.静态类型"></a>1.静态类型</h3><p>TypeScript是一种静态类型的语言，它允许您在编写代码时指定变量的类型。通过类型注解，您可以告诉编译器变量的类型，从而在编码阶段捕获潜在的错误。</p>
<h3 id="2-类型注解"><a href="#2-类型注解" class="headerlink" title="2.类型注解"></a>2.类型注解</h3><p>类型注解是指在变量或函数声明时使用冒号（:）指定类型。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>age</code>变量的类型被注解为<code>number</code>，<code>add</code>函数的参数和返回值的类型也被注解为<code>number</code>。</p>
<h3 id="3-接口（Interfaces）"><a href="#3-接口（Interfaces）" class="headerlink" title="3.接口（Interfaces）"></a>3.接口（Interfaces）</h3><p>接口是TypeScript中用于描述对象结构的方式。您可以使用接口定义对象的属性和方法，以及它们的类型。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">greet</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述接口<code>Person</code>定义了一个具有<code>name</code>和<code>age</code>属性以及一个<code>greet</code>方法的对象。</p>
<h3 id="4-类（Classes）"><a href="#4-类（Classes）" class="headerlink" title="4.类（Classes）"></a>4.类（Classes）</h3><p>类是面向对象编程的核心概念之一。您可以使用类来创建具有属性和方法的对象。以下是一个简单的类的示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">greeter.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>Greeter</code>类具有一个<code>greeting</code>属性和一个<code>greet</code>方法。通过<code>new</code>关键字创建一个类的实例，并调用该实例的<code>greet</code>方法。</p>
<h3 id="5-枚举（Enums）"><a href="#5-枚举（Enums）" class="headerlink" title="5.枚举（Enums）"></a>5.枚举（Enums）</h3><p>枚举允许您定义一组命名的常量。使用枚举可以提高代码的可读性和可维护性。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myColor</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>Color</code>是一个枚举，包含了<code>Red</code>、<code>Green</code>和<code>Blue</code>三个常量。通过赋值给<code>myColor</code>变量，可以使用枚举中定义的常量。</p>
<h3 id="6-泛型（Generics）"><a href="#6-泛型（Generics）" class="headerlink" title="6.泛型（Generics）"></a>6.泛型（Generics）</h3><p>泛型允许您编写可以在多种类型上工作的可重用代码。通过使用泛型，您可以在编写函数、类和接口时增加类型的灵活性和安全性。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>identity</code>函数使用泛型类型参数<code>T</code>，它接收一个参数并返回相同类型的值。通过显式指定类型参数为<code>string</code>，我们可以将函数应用于特定类型的值。</p>
<h3 id="7-模块化（Modules）"><a href="#7-模块化（Modules）" class="headerlink" title="7.模块化（Modules）"></a>7.模块化（Modules）</h3><p>TypeScript支持模块化的开发方式，允许您将代码分割成多个模块，并通过导入和导出语法在模块之间共享代码。这样可以提高代码的可维护性和复用性。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.ts 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.ts 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&quot;./math&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>math.ts</code>模块导出了一个<code>add</code>函数，<code>main.ts</code>模块使用<code>import</code>语句导入了<code>add</code>函数，并在代码中调用它。</p>
<p>这些是TypeScript的一些其他功能的简要介绍。TypeScript还提供了许多其他功能，如装饰器（Decorators）、异步编程支持、命名空间（Namespaces）等，可以根据您的需求进行更深入的学习和应用。</p>
<p>如果您对特定功能有进一步的疑问或需要更详细的解释，请随时提问！我将很乐意帮助您。</p>
<h2 id="二、学习如何声明变量、函数和类"><a href="#二、学习如何声明变量、函数和类" class="headerlink" title="二、学习如何声明变量、函数和类"></a>二、学习如何声明变量、函数和类</h2><p>在TypeScript中，您可以使用以下语法来声明变量、函数和类：</p>
<h3 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="1.变量声明"></a>1.变量声明</h3><p>使用关键字<code>let</code>或<code>const</code>可以声明变量，并使用冒号（:）指定变量的类型。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">25</span>;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>name</code>变量的类型被声明为<code>string</code>，<code>age</code>变量的类型被声明为<code>number</code>。</p>
<h3 id="2-函数声明"><a href="#2-函数声明" class="headerlink" title="2.函数声明"></a>2.函数声明</h3><p>使用关键字<code>function</code>可以声明函数，并使用冒号（:）指定参数的类型和返回值的类型。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>add</code>函数接受两个参数，类型为<code>number</code>，并返回一个<code>number</code>类型的值。</p>
<h3 id="3-类声明"><a href="#3-类声明" class="headerlink" title="3.类声明"></a>3.类声明</h3><p>使用关键字<code>class</code>可以声明类，并使用冒号（:）指定类的类型。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>Person</code>类具有<code>name</code>和<code>age</code>属性，以及一个<code>greet</code>方法</p>
<p>这些是声明变量、函数和类的基本语法。在TypeScript中，通过明确指定类型，可以提供更好的代码安全性和可读性。</p>
<p>请注意，在TypeScript中，还可以使用类型推断来自动推断变量和函数的类型，如果没有显式指定类型，编译器会根据赋值和上下文推断类型。</p>
<h2 id="三、理解静态类型和类型注解的概念"><a href="#三、理解静态类型和类型注解的概念" class="headerlink" title="三、理解静态类型和类型注解的概念"></a>三、理解静态类型和类型注解的概念</h2><p>静态类型和类型注解是TypeScript中重要的概念，它们有助于增强代码的可靠性和可维护性。</p>
<h3 id="1-静态类型（Static-Typing）"><a href="#1-静态类型（Static-Typing）" class="headerlink" title="1.静态类型（Static Typing）"></a>1.静态类型（Static Typing）</h3><p>静态类型是指在编译时确定变量、函数和类的类型，并进行类型检查的特性。在静态类型语言中，类型在编译阶段就被确定，并且变量在声明时必须指定其类型。在TypeScript中，静态类型可以提前捕获一些潜在的错误，例如类型不匹配、未定义的变量等，从而减少在运行时出现的错误。</p>
<p>例如，在TypeScript中声明一个变量时，可以显式指定其类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">25</span>;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>name</code>变量的类型被声明为<code>string</code>，<code>age</code>变量的类型被声明为<code>number</code>，这样在编译时就会进行类型检查，确保变量的使用符合其声明的类型。</p>
<h3 id="2-类型注解（Type-Annotations）"><a href="#2-类型注解（Type-Annotations）" class="headerlink" title="2.类型注解（Type Annotations）"></a>2.类型注解（Type Annotations）</h3><p>类型注解是在变量、函数参数、函数返回值等地方显式地注明类型信息的语法。通过类型注解，开发人员可以明确指定变量、函数的参数和返回值的类型，使代码更加清晰和可读。</p>
<p>例如，在函数声明中使用类型注解：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>add</code>函数的参数<code>a</code>和<code>b</code>都被注解为<code>number</code>类型，返回值也被注解为<code>number</code>类型。</p>
<p>类型注解的好处是可以提供更好的代码提示和类型检查，使开发人员能够更早地发现潜在的错误。</p>
<p>总结：<br>静态类型和类型注解是TypeScript中的关键概念。静态类型带来了更强的类型安全性和可靠性，而类型注解则是显式地注明变量、函数参数和返回值的类型信息，增强了代码的可读性和可维护性。</p>
<h1 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h1><h2 id="一、深入了解TypeScript的类型系统，包括原始类型、数组、元组、枚举等"><a href="#一、深入了解TypeScript的类型系统，包括原始类型、数组、元组、枚举等" class="headerlink" title="一、深入了解TypeScript的类型系统，包括原始类型、数组、元组、枚举等"></a>一、深入了解TypeScript的类型系统，包括原始类型、数组、元组、枚举等</h2><p>TypeScript的类型系统非常丰富，支持许多不同类型的数据。以下是一些常见的类型及其用法：</p>
<h3 id="1-原始类型（Primitive-Types）"><a href="#1-原始类型（Primitive-Types）" class="headerlink" title="1.原始类型（Primitive Types）"></a>1.原始类型（Primitive Types）</h3><ul>
<li><code>number</code>：表示数值类型，包括整数和浮点数。</li>
<li><code>string</code>：表示字符串类型，用单引号或双引号括起来的字符序列。</li>
<li><code>boolean</code>：表示布尔类型，即<code>true</code>或<code>false</code>。</li>
<li><code>null</code>：表示空值或空引用。</li>
<li><code>undefined</code>：表示未定义的值。</li>
<li><code>symbol</code>：表示唯一的、不可变的值。</li>
</ul>
<h3 id="2-数组（Arrays）"><a href="#2-数组（Arrays）" class="headerlink" title="2.数组（Arrays）"></a>2.数组（Arrays）</h3><p>使用数组类型可以定义包含特定类型元素的数组。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">numbers</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">names</span>: <span class="built_in">string</span>[] = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="3-元组（Tuples）"><a href="#3-元组（Tuples）" class="headerlink" title="3.元组（Tuples）"></a>3.元组（Tuples）</h3><p>元组是表示具有固定数量和类型的元素的数组。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;John&#x27;</span>, <span class="number">25</span>];</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>person</code>是一个包含两个元素的元组，第一个元素是字符串类型，第二个元素是数值类型。</p>
<h3 id="4-枚举（Enums）"><a href="#4-枚举（Enums）" class="headerlink" title="4.枚举（Enums）"></a>4.枚举（Enums）</h3><p>枚举用于定义一组具名的常量。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">favoriteColor</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Blue</span>;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>Color</code>是一个枚举类型，它定义了<code>Red</code>、<code>Green</code>和<code>Blue</code>三个常量。<code>favoriteColor</code>变量被赋值为<code>Color.Blue</code>，表示它的喜好颜色是蓝色。</p>
<h2 id="二、学习如何定义和使用接口和类型别名"><a href="#二、学习如何定义和使用接口和类型别名" class="headerlink" title="二、学习如何定义和使用接口和类型别名"></a>二、学习如何定义和使用接口和类型别名</h2><p>在TypeScript中，接口（Interfaces）和类型别名（Type Aliases）是用于定义自定义类型的重要工具。</p>
<h3 id="1-接口（Interfaces）"><a href="#1-接口（Interfaces）" class="headerlink" title="1.接口（Interfaces）"></a>1.接口（Interfaces）</h3><p>接口用于定义对象的结构和属性。通过接口，可以指定对象应具有哪些属性和方法，并且可以定义它们的类型。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，定义了一个<code>Person</code>接口，它具有<code>name</code>和<code>age</code>属性，以及一个返回值为空的<code>sayHello</code>方法。然后，使用该接口定义了一个<code>person</code>对象，该对象符合<code>Person</code>接口的结构和类型要求。</p>
<h3 id="2-类型别名（Type-Aliases）"><a href="#2-类型别名（Type-Aliases）" class="headerlink" title="2.类型别名（Type Aliases）"></a>2.类型别名（Type Aliases）</h3><p>类型别名允许为现有类型创建一个新名称。它们可以用于简化复杂类型的表示或为特定类型添加描述。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，定义了一个名为<code>Point</code>的类型别名，它表示一个具有<code>x</code>和<code>y</code>属性的对象。然后，使用该类型别名定义了一个<code>p</code>对象，该对象符合<code>Point</code>类型的结构和类型要求。</p>
<p>类型别名还可以与联合类型、交叉类型等结合使用，提供更复杂的类型定义。</p>
<p>接口和类型别名在定义自定义类型时都非常有用，选择使用哪个取决于具体情况。一般来说，当需要描述对象的结构和属性时，可以优先考虑使用接口；而当需要为现有类型创建一个新名称或定义复杂类型时，可以使用类型别名。</p>
<h2 id="三、探索泛型的概念和用法"><a href="#三、探索泛型的概念和用法" class="headerlink" title="三、探索泛型的概念和用法"></a>三、探索泛型的概念和用法</h2><p>泛型（Generics）是一种在编程语言中用于创建可重用、通用的代码的概念。它允许在定义函数、类或接口时使用参数化类型，以便在使用时指定具体的类型。泛型提供了更大的灵活性和类型安全性，使代码能够适应不同的数据类型。</p>
<p>以下是泛型的一些常见用法和概念：</p>
<h3 id="1-泛型函数（Generic-Functions）"><a href="#1-泛型函数（Generic-Functions）" class="headerlink" title="1.泛型函数（Generic Functions）"></a>1.泛型函数（Generic Functions）</h3><p>可以在函数定义中使用泛型参数来表示函数的参数类型、返回类型或两者。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;Hello&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>identity</code>函数使用了泛型参数<code>&lt;T&gt;</code>，它表示函数可以接受任意类型的参数，并返回相同类型的结果。在调用函数时，通过传递类型参数<code>&lt;string&gt;</code>来指定具体的类型。</p>
<h3 id="2-泛型类（Generic-Classes）"><a href="#2-泛型类（Generic-Classes）" class="headerlink" title="2.泛型类（Generic Classes）"></a>2.泛型类（Generic Classes）</h3><p>类也可以使用泛型参数来定义可重用的通用类。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">value</span>: T;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getValue</span>(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> container = <span class="keyword">new</span> <span class="title class_">Container</span>&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> value = container.<span class="title function_">getValue</span>();</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>Container</code>类使用了泛型参数<code>&lt;T&gt;</code>，它表示类中的值可以是任意类型。在创建类实例时，通过传递类型参数<code>&lt;number&gt;</code>来指定具体的类型。</p>
<h3 id="3-泛型接口（Generic-Interfaces）"><a href="#3-泛型接口（Generic-Interfaces）" class="headerlink" title="3.泛型接口（Generic Interfaces）"></a>3.泛型接口（Generic Interfaces）</h3><p>接口也可以使用泛型参数来定义通用接口。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">List</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">item</span>: T): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">get</span>(<span class="attr">index</span>: <span class="built_in">number</span>): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">items</span>: T[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">item</span>: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="attr">index</span>: <span class="built_in">number</span>): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myList = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myList.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> value = myList.<span class="title function_">get</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>List</code>接口使用了泛型参数<code>&lt;T&gt;</code>，它表示接口中的方法可以操作任意类型的数据。<code>MyList</code>类实现了<code>List</code>接口，并通过类型参数<code>&lt;number&gt;</code>指定了具体的类型。</p>
<p>泛型在许多情况下都非常有用，特别是在编写通用的数据结构和算法时。它提供了更强大的类型检查和类型推断，使代码更安全和可维护。使用泛型可以提高代码的重用性，并且能够处理各种不同类型的数据。</p>
<h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="一、学习TypeScript中的模块化和命名空间"><a href="#一、学习TypeScript中的模块化和命名空间" class="headerlink" title="一、学习TypeScript中的模块化和命名空间"></a>一、学习TypeScript中的模块化和命名空间</h2><p>在TypeScript中，模块化和命名空间是组织和管理代码的重要概念。它们有助于将代码分割成可维护和可重用的模块，并提供了一种避免命名冲突的机制。让我们逐个介绍这两个概念。</p>
<h3 id="1-模块化（Modules）"><a href="#1-模块化（Modules）" class="headerlink" title="1.模块化（Modules）"></a>1.模块化（Modules）</h3><p>模块化是将代码划分为独立的功能模块，每个模块负责特定的任务。模块可以包含变量、函数、类和接口等，并且可以导出（export）这些定义，使其可供其他模块引用。同时，模块也可以导入（import）其他模块中导出的内容，以便在当前模块中使用。</p>
<p>例如，假设我们有一个名为<code>math.ts</code>的模块，其中定义了一些数学相关的函数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在另一个文件中可以导入并使用这些函数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add, multiply &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出: 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiply</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出: 6</span></span><br></pre></td></tr></table></figure>

<p>使用模块化可以提高代码的可维护性和可重用性，同时避免了全局命名冲突的问题。</p>
<h3 id="2-命名空间（Namespaces）"><a href="#2-命名空间（Namespaces）" class="headerlink" title="2.命名空间（Namespaces）"></a>2.命名空间（Namespaces）</h3><p>命名空间提供了一种将相关的代码组织在一起的机制，以避免全局作用域中的命名冲突。命名空间可以包含变量、函数、类和接口等定义，并使用<code>namespace</code>关键字进行声明。</p>
<p>例如，假设我们有一个名为<code>Geometry</code>的命名空间，其中包含了一些几何图形的定义：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Geometry</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">distance</span>(<span class="params">p1: Point, p2: Point</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dx = p2.<span class="property">x</span> - p1.<span class="property">x</span>;</span><br><span class="line">    <span class="keyword">const</span> dy = p2.<span class="property">y</span> - p1.<span class="property">y</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在另一个文件中可以通过命名空间访问这些定义：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: <span class="title class_">Geometry</span>.<span class="property">Point</span> = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p2</span>: <span class="title class_">Geometry</span>.<span class="property">Point</span> = &#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Geometry</span>.<span class="title function_">distance</span>(p1, p2)); <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure>

<p>使用命名空间可以将相关的代码组织在一起，并提供更好的代码结构和可读性。</p>
<p>需要注意的是，TypeScript也支持使用模块化语法来替代命名空间。</p>
<h2 id="二、理解装饰器的作用和使用方式"><a href="#二、理解装饰器的作用和使用方式" class="headerlink" title="二、理解装饰器的作用和使用方式"></a>二、理解装饰器的作用和使用方式</h2><p>装饰器（Decorators）是一种在类、方法、属性或参数上附加元数据的特殊类型声明。它们提供了一种简洁且可重用的方式来修改类的行为或修改类中的成员。</p>
<p>装饰器可以在不修改源代码的情况下，通过在类或成员周围添加装饰器来改变它们的行为。装饰器使用 <code>@</code> 符号紧跟着一个装饰器工厂函数或装饰器工厂表达式的形式来定义。</p>
<p>下面是一些常见的装饰器示例：</p>
<h3 id="1-类装饰器（Class-Decorators）"><a href="#1-类装饰器（Class-Decorators）" class="headerlink" title="1.类装饰器（Class Decorators）"></a>1.类装饰器（Class Decorators）</h3><p>类装饰器用于修改类的行为。它们在类声明之前声明，并接收类的构造函数作为参数。常见的用途包括添加额外的功能、修改类的属性或方法等。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">classDecorator</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Class decorator&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@classDecorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="comment">// 类的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-方法装饰器（Method-Decorators）"><a href="#2-方法装饰器（Method-Decorators）" class="headerlink" title="2.方法装饰器（Method Decorators）"></a>2.方法装饰器（Method Decorators）</h3><p>方法装饰器用于修改类中的方法。它们在方法声明之前声明，并接收三个参数：类的原型、方法名称和方法的属性描述符。常见的用途包括添加日志、验证或修改方法的行为。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">methodDecorator</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Method decorator&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="meta">@methodDecorator</span></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 方法的定义</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-属性装饰器（Property-Decorators）"><a href="#3-属性装饰器（Property-Decorators）" class="headerlink" title="3.属性装饰器（Property Decorators）"></a>3.属性装饰器（Property Decorators）</h3><p>属性装饰器用于修改类中的属性。它们在属性声明之前声明，并接收两个参数：类的原型和属性名称。常见的用途包括添加额外的属性或修改属性的行为。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">propertyDecorator</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Property decorator&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="meta">@propertyDecorator</span></span><br><span class="line">  <span class="attr">myProperty</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.参数装饰器（Parameter Decorators）<br>参数装饰器用于修改类中方法的参数。它们在参数声明之前声明，并接收三个参数：类的原型、方法名称和参数的索引。常见的用途包括参数验证或修改参数的值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parameterDecorator</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, parameterIndex: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Parameter decorator&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params"><span class="meta">@parameterDecorator</span> param: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 方法的定义</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>装饰器可以通过链式使用，多个装饰器按照从上到下的顺序依次执行。装饰器的执行顺序可以影响修改的结果。</p>
<p>需要注意的是，装饰器是一个实验性的特性，在TypeScript中需要启用 <code>experimentalDecorators</code> 和 <code>emitDecoratorMetadata</code> 选项来使用装饰器。此外，装饰器功能目前在不同的JavaScript运行时和编译器之间存在一些差异。</p>
<h2 id="三、探索异步编程和Promise、async-x2F-await等特性"><a href="#三、探索异步编程和Promise、async-x2F-await等特性" class="headerlink" title="三、探索异步编程和Promise、async&#x2F;await等特性"></a>三、探索异步编程和Promise、async&#x2F;await等特性</h2><p>异步编程是指在程序执行过程中可以同时执行多个操作，而不会阻塞其他代码的执行。TypeScript提供了一些特性来简化异步编程，包括Promise、async&#x2F;await等。</p>
<h3 id="1-Promise"><a href="#1-Promise" class="headerlink" title="1.Promise"></a>1.Promise</h3><p>Promise 是一种表示异步操作的对象，它可以用于处理异步操作的成功或失败，并提供了一种链式调用的方式。Promise 可以被认为是一个包装了异步操作的容器，它可以有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchData = (): <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">      <span class="title function_">resolve</span>(data); <span class="comment">// 异步操作成功时调用 resolve</span></span><br><span class="line">      <span class="comment">// reject(new Error(&quot;Something went wrong&quot;)); // 异步操作失败时调用 reject</span></span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchData</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// 在异步操作成功后执行</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error); <span class="comment">// 在异步操作失败后执行</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="2-async-x2F-await"><a href="#2-async-x2F-await" class="headerlink" title="2.async&#x2F;await"></a>2.async&#x2F;await</h3><p>async&#x2F;await 是一种更加简洁和直观的异步编程方式，它是基于 Promise 的语法糖。使用 async 关键字声明的函数会返回一个 Promise 对象，并且可以在函数内部使用 await 关键字来等待一个 Promise 的解析结果。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchData = (): <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">      <span class="title function_">resolve</span>(data); <span class="comment">// 异步操作成功时调用 resolve</span></span><br><span class="line">      <span class="comment">// reject(new Error(&quot;Something went wrong&quot;)); // 异步操作失败时调用 reject</span></span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchDataAsync = <span class="keyword">async</span> (): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetchData</span>(); <span class="comment">// 等待 Promise 解析结果</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// 在异步操作成功后执行</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error); <span class="comment">// 在异步操作失败后执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchDataAsync</span>();</span><br></pre></td></tr></table></figure>

<p>使用 async&#x2F;await 可以使异步代码的编写更加类似于同步代码的风格，增强了代码的可读性和可维护性。</p>
<p>除了 Promise 和 async&#x2F;await，TypeScript 还提供了其他一些处理异步编程的特性，如生成器函数（Generator Functions）和异步迭代器（Async Iterators），它们更适用于一些特定的场景和需求。</p>
<h1 id="与JavaScript的互操作性"><a href="#与JavaScript的互操作性" class="headerlink" title="与JavaScript的互操作性"></a>与JavaScript的互操作性</h1><h2 id="一、学习如何使用TypeScript与现有的JavaScript库和框架进行交互"><a href="#一、学习如何使用TypeScript与现有的JavaScript库和框架进行交互" class="headerlink" title="一、学习如何使用TypeScript与现有的JavaScript库和框架进行交互"></a>一、学习如何使用TypeScript与现有的JavaScript库和框架进行交互</h2><p>当使用 TypeScript 与现有的 JavaScript 库和框架进行交互时，你可以采取以下几种方法：</p>
<h3 id="1-类型声明文件（Type-Declaration-Files）"><a href="#1-类型声明文件（Type-Declaration-Files）" class="headerlink" title="1.类型声明文件（Type Declaration Files）"></a>1.类型声明文件（Type Declaration Files）</h3><p>TypeScript 使用类型声明文件（通常以 <code>.d.ts</code> 为扩展名）来描述 JavaScript 库和框架的类型信息。这些声明文件包含了类型定义和接口声明，以便在 TypeScript 中进行类型检查和智能提示。</p>
<p>你可以在 DefinitelyTyped（<a href="https://definitelytyped.org/%EF%BC%89%E7%BD%91%E7%AB%99%E4%B8%8A%E6%89%BE%E5%88%B0%E5%90%84%E7%A7%8D%E6%B5%81%E8%A1%8C%E7%9A%84">https://definitelytyped.org/）网站上找到各种流行的</a> JavaScript 库和框架的类型声明文件。将所需的声明文件安装到你的 TypeScript 项目中，然后就可以与该库或框架进行类型安全的交互。</p>
<h3 id="2-声明全局变量（Declare-Global-Variables）"><a href="#2-声明全局变量（Declare-Global-Variables）" class="headerlink" title="2.声明全局变量（Declare Global Variables）"></a>2.声明全局变量（Declare Global Variables）</h3><p>如果你要与一个没有类型声明文件的 JavaScript 库或框架进行交互，你可以使用 <code>declare</code> 关键字声明全局变量，以便 TypeScript 可以识别和推断这些变量的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="title class_">MyLibrary</span>: <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<p>这样，你就可以在 TypeScript 中使用 <code>MyLibrary</code> 变量，尽管它没有明确定义类型。</p>
<h3 id="3-类型断言（Type-Assertion）"><a href="#3-类型断言（Type-Assertion）" class="headerlink" title="3.类型断言（Type Assertion）"></a>3.类型断言（Type Assertion）</h3><p>当你确定某个变量的类型时，你可以使用类型断言来告诉 TypeScript 编译器该变量的实际类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">result</span>: <span class="built_in">any</span> = <span class="title function_">someFunction</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">specificResult</span>: <span class="title class_">SpecificType</span> = result <span class="keyword">as</span> <span class="title class_">SpecificType</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>result</code> 变量的类型被断言为 <code>SpecificType</code>，以便在后续代码中以正确的类型使用它。</p>
<h3 id="4-扩展类型定义"><a href="#4-扩展类型定义" class="headerlink" title="4.扩展类型定义"></a>4.扩展类型定义</h3><p>如果你发现某个库或框架的类型声明文件不完整或不准确，你可以创建一个自定义的类型声明文件来扩展它们的类型定义。</p>
<p>创建一个以 <code>.d.ts</code> 为扩展名的新文件，并在其中编写相应的类型声明。例如，你可以声明一个全局模块来扩展某个库的类型定义。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// custom.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;my-library&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，你可以在代码中使用 <code>import</code> 或 <code>require</code> 来导入你自定义的类型声明。</p>
<h3 id="5-使用第三方库的-TypeScript-版本"><a href="#5-使用第三方库的-TypeScript-版本" class="headerlink" title="5.使用第三方库的 TypeScript 版本"></a>5.使用第三方库的 TypeScript 版本</h3><p>有些流行的 JavaScript 库和框架已经提供了官方的 TypeScript 版本，这些版本包含了完整的类型定义，可以直接在 TypeScript 项目中使用。</p>
<p>你可以通过 npm 或 yarn 等包管理工具安装这些 TypeScript 版本的库，然后在代码中导入并使用它们。</p>
<p>以上是几种常用的方法，用于在 TypeScript 中与现有的 JavaScript 库和框架进行交互。根据具体的情况和需求，你可以选择适合的方法来获得类型安全和良好的开发体验。</p>
<h2 id="二、理解类型声明文件和如何使用它们扩展JavaScript库的类型信息"><a href="#二、理解类型声明文件和如何使用它们扩展JavaScript库的类型信息" class="headerlink" title="二、理解类型声明文件和如何使用它们扩展JavaScript库的类型信息"></a>二、理解类型声明文件和如何使用它们扩展JavaScript库的类型信息</h2><p>类型声明文件（Type Declaration Files）是用于描述 JavaScript 库和框架的类型信息的文件。它们为 TypeScript 提供了与 JavaScript 库进行类型安全交互的能力。类型声明文件通常具有 <code>.d.ts</code> 的文件扩展名。</p>
<p>类型声明文件包含了库的函数、对象、类和模块的类型定义和接口声明。它们告诉 TypeScript 编译器如何理解和推断 JavaScript 库的类型，从而提供类型检查、智能提示和代码补全等功能。</p>
<p>以下是使用类型声明文件扩展 JavaScript 库类型信息的步骤：</p>
<h3 id="1-安装类型声明文件"><a href="#1-安装类型声明文件" class="headerlink" title="1.安装类型声明文件"></a>1.安装类型声明文件</h3><p>首先，你需要找到适合你使用的 JavaScript 库的类型声明文件。可以通过 npm 包管理器来安装类型声明文件，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @types/library-name</span><br></pre></td></tr></table></figure>

<p>上述命令会安装名为 <code>@types/library-name</code> 的类型声明文件，其中 <code>library-name</code> 是你要扩展的 JavaScript 库的名称。</p>
<h3 id="2-引入类型声明文件"><a href="#2-引入类型声明文件" class="headerlink" title="2.引入类型声明文件"></a>2.引入类型声明文件</h3><p>在 TypeScript 项目中，你需要在代码文件中引入类型声明文件，以便 TypeScript 编译器可以读取和使用其中的类型信息。你可以使用 <code>import</code> 或 <code>/// &lt;reference&gt;</code> 来引入类型声明文件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 import 引入类型声明文件</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> libraryName <span class="keyword">from</span> <span class="string">&#x27;library-name&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 /// &lt;reference&gt; 引入类型声明文件</span></span><br><span class="line"><span class="comment">/// &lt;reference types=&quot;library-name&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<p>确保在你的代码文件中正确引入了相关的类型声明文件。</p>
<h3 id="3-使用库的类型信息"><a href="#3-使用库的类型信息" class="headerlink" title="3.使用库的类型信息"></a>3.使用库的类型信息</h3><p>一旦你引入了类型声明文件，TypeScript 编译器就能够根据其中的类型信息提供代码补全、智能提示和类型检查等功能。你可以使用库提供的函数、对象、类和模块，并获得与 JavaScript 类似的开发体验。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用库提供的函数</span></span><br><span class="line">libraryName.<span class="title function_">someFunction</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用库提供的对象</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> libraryName.<span class="title class_">SomeClass</span>();</span><br><span class="line">instance.<span class="title function_">someMethod</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用库提供的模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; someFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;library-name/module-name&#x27;</span>;</span><br><span class="line"><span class="title function_">someFunction</span>();</span><br></pre></td></tr></table></figure>

<p>TypeScript 编译器会根据类型声明文件中的定义，对这些代码进行类型检查，以确保类型的正确性。</p>
<p>通过使用类型声明文件，你可以在 TypeScript 项目中获得与 JavaScript 库的类型安全交互。这为你提供了在开发过程中捕获潜在错误、提供智能提示和增强开发体验的能力。确保选择适合你使用的库的类型声明文件，并正确引入它们，以便发挥 TypeScript 的优势。</p>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><h2 id="一、探索如何在实际项目中使用TypeScript"><a href="#一、探索如何在实际项目中使用TypeScript" class="headerlink" title="一、探索如何在实际项目中使用TypeScript"></a>一、探索如何在实际项目中使用TypeScript</h2><p>在实际项目中使用 TypeScript 可以提供许多优势，包括更好的代码可维护性、更强的类型检查、更好的开发工具支持和更好的团队协作。下面是一些步骤和实践，可以帮助你在实际项目中成功地使用 TypeScript：</p>
<ol>
<li><p><strong>创建 TypeScript 项目</strong><br>首先，你需要创建一个 TypeScript 项目。你可以使用命令行或集成开发环境（IDE）来创建项目。在项目目录中运行以下命令来初始化 TypeScript 项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure>

<p>这将创建一个 <code>tsconfig.json</code> 文件，用于配置 TypeScript 项目的编译选项。</p>
</li>
<li><p><strong>配置 tsconfig.json</strong><br>打开 <code>tsconfig.json</code> 文件，并根据项目需求进行相应的配置。你可以指定编译目标版本、模块系统、输出目录等选项。还可以根据需求启用或禁用不同的 TypeScript 特性。</p>
</li>
<li><p><strong>将 JavaScript 文件重命名为 TypeScript 文件</strong><br>如果你已经有现有的 JavaScript 代码，你可以将其文件扩展名从 <code>.js</code> 改为 <code>.ts</code>。这样，TypeScript 编译器将开始检查并推断你的代码的类型。</p>
</li>
<li><p><strong>逐步启用严格的类型检查</strong><br>TypeScript 提供了不同级别的类型检查，你可以逐步启用更严格的检查。在 <code>tsconfig.json</code> 文件中，可以设置 <code>&quot;strict&quot;</code> 选项为 <code>true</code> 来启用严格模式。这将帮助你在开发过程中捕获潜在的类型错误，并提供更好的代码质量和可维护性。</p>
</li>
<li><p><strong>定义接口和类型</strong><br>TypeScript 的主要优势之一是类型系统。利用接口和类型别名来定义你的数据结构和函数签名。这样可以提供更好的代码提示和类型检查。</p>
</li>
<li><p><strong>使用模块化</strong><br>使用 TypeScript 的模块化系统（如 ES 模块或 CommonJS）来组织你的代码，并使用 <code>import</code> 和 <code>export</code> 关键字来导入和导出模块。这有助于代码的可重用性和可维护性。</p>
</li>
<li><p><strong>使用第三方库和类型声明文件</strong><br>如果你在项目中使用第三方 JavaScript 库，可以使用类型声明文件来提供类型信息。安装相应的类型声明文件（如 <code>@types/library-name</code>）并在代码中导入库时使用类型检查。</p>
</li>
<li><p><strong>使用工具和插件</strong><br>利用 TypeScript 提供的丰富工具生态系统来增强开发体验。使用编辑器或 IDE 中的 TypeScript 插件，例如代码补全、智能提示、错误检查和重构功能。</p>
</li>
<li><p><strong>进行类型测试和代码重构</strong><br>使用 TypeScript 提供的类型检查功能，运行项目中的测试套件，以确保代码在类型安全的环</p>
</li>
</ol>
<p>境中工作。使用 TypeScript 的重构工具来改进代码结构和可读性。</p>
<ol start="10">
<li><strong>持续学习和社区参与</strong><br>TypeScript 是一个不断发展的技术，持续学习新特性和最佳实践是提高使用 TypeScript 技能的关键。参与 TypeScript 社区，查阅文档、教程和博客文章，与其他开发者分享经验。</li>
</ol>
<p>以上是一些使用 TypeScript 的实践建议，帮助你在实际项目中顺利应用 TypeScript。根据你的项目需求和团队情况，可以适当调整和扩展这些实践。</p>
<h2 id="二、学习调试和构建TypeScript应用程序的技巧"><a href="#二、学习调试和构建TypeScript应用程序的技巧" class="headerlink" title="二、学习调试和构建TypeScript应用程序的技巧"></a>二、学习调试和构建TypeScript应用程序的技巧</h2><p>当你开发和构建 TypeScript 应用程序时，以下是一些调试和构建的技巧可以帮助你提高开发效率和确保应用程序的质量：</p>
<h3 id="1-调试技巧"><a href="#1-调试技巧" class="headerlink" title="1.调试技巧"></a>1.调试技巧</h3><ol>
<li><p>使用调试器：利用你的集成开发环境（IDE）或浏览器开发工具中的调试器来逐步执行代码、检查变量的值、设置断点和跟踪代码执行流程。</p>
</li>
<li><p>使用断点：在关键的代码行上设置断点，这样当应用程序执行到断点时，调试器将会暂停代码执行，让你能够检查当前状态和变量的值。</p>
</li>
<li><p>使用日志输出：在代码中使用日志输出语句（如 <code>console.log</code>）来输出变量的值、函数执行结果等，以便在开发过程中查看和验证代码的执行情况。</p>
</li>
<li><p>利用调试工具：使用 TypeScript 提供的调试工具，如 <code>ts-debug</code>，可以在开发过程中更方便地调试 TypeScript 代码。</p>
</li>
</ol>
<h3 id="2-构建技巧"><a href="#2-构建技巧" class="headerlink" title="2.构建技巧"></a>2.构建技巧</h3><ol>
<li><p>配置构建工具：使用常见的构建工具（如 Webpack、Parcel、Rollup 等）来打包和构建 TypeScript 应用程序。配置构建工具以正确处理 TypeScript 文件并生成可部署的 JavaScript 代码。</p>
</li>
<li><p>使用模块打包器：使用模块打包器（如 Webpack）将你的 TypeScript 模块打包成一个或多个捆绑文件，以便在浏览器中加载和执行。</p>
</li>
<li><p>优化构建过程：针对你的应用程序进行构建优化，例如使用代码分割、压缩和缓存等技术，以提高应用程序的性能和加载速度。</p>
</li>
<li><p>集成类型检查：在构建过程中使用 TypeScript 的类型检查功能，确保没有类型错误和潜在的问题。将类型检查作为构建过程的一部分，可以提前捕获错误，并避免将类型错误部署到生产环境中。</p>
</li>
<li><p>使用构建脚本：编写自定义的构建脚本，以自动执行构建任务，如编译 TypeScript、拷贝静态资源、运行测试等。使用构建工具或脚本管理工具（如 npm scripts）来定义和运行这些构建任务。</p>
</li>
<li><p>运行测试套件：在构建过程中集成测试套件，以确保构建的应用程序在各种场景下都能正常工作。使用测试框架（如 Jest、Mocha、Karma 等）和断言库（如 Chai、Jasmine 等）编写和执行测试。</p>
</li>
<li><p>部署和版本控制：使用版本控制系统（如 Git）管理你的代码，并使用自动化工具或流程来部署和发布应用程序。确保在构建过程中生成可靠和可部署的代码包，并使用适当的版本控制策略来管理代码的发布和迭代。</p>
</li>
</ol>
<h2 id="三、了解TypeScript在大型项目和团队中的最佳实践"><a href="#三、了解TypeScript在大型项目和团队中的最佳实践" class="headerlink" title="三、了解TypeScript在大型项目和团队中的最佳实践"></a>三、了解TypeScript在大型项目和团队中的最佳实践</h2><p>在大型项目和团队中使用 TypeScript，以下是一些最佳实践可以帮助你提高开发效率、代码质量和团队协作：</p>
<ol>
<li><p>使用严格的类型检查：在 TypeScript 中，启用严格的类型检查选项（如 <code>&quot;strict&quot;: true</code>）可以帮助捕获潜在的类型错误和编码问题。这有助于提高代码质量并减少在运行时出现的错误。</p>
</li>
<li><p>制定一致的命名规范：在项目中制定一致的命名规范，包括变量、函数、类和文件的命名方式。这有助于提高代码的可读性和维护性，并使团队成员更容易理解和使用代码。</p>
</li>
<li><p>使用模块化组织代码：将代码组织为模块，使用模块化的导入和导出语法。这样可以将代码分离为可重用的模块，并提供更好的可扩展性和代码组织结构。</p>
</li>
<li><p>使用接口和类型定义：合理使用接口和类型别名来定义数据结构、函数签名和类的形状。这有助于提供清晰的类型定义，使代码更具可读性和可理解性。</p>
</li>
<li><p>设计可复用的类型：在大型项目中，经常会遇到需要在多个地方重复使用的类型。为这些类型创建可复用的类型定义，可以提高代码的可维护性和可扩展性。</p>
</li>
<li><p>使用工具和编辑器插件：利用 TypeScript 的生态系统中的工具和编辑器插件，如 TypeScript ESLint、Prettier、TypeScript 编辑器支持等，以提高代码的质量、一致性和开发效率。</p>
</li>
<li><p>编写清晰的文档：在大型项目中，编写清晰、详细的文档非常重要。文档应包括代码使用示例、API 文档、项目结构和架构说明等，以帮助团队成员了解和使用代码。</p>
</li>
<li><p>使用版本控制和代码审查：使用版本控制系统（如 Git）来管理代码，并实施代码审查流程。代码审查有助于发现潜在的问题、改进代码质量，并提高团队成员之间的沟通和协作。</p>
</li>
<li><p>编写单元测试和集成测试：编写全面的单元测试和集成测试来验证代码的正确性和稳定性。测试可以帮助发现潜在的问题，确保代码在变更和扩展时仍然正常工作。</p>
</li>
<li><p>持续集成和持续交付：在大型项目中实施持续集成和持续交付（CI&#x2F;CD）流程，自动化构建、测试和部署过程。这有助于确保代码的质量和稳定性，并提高团队的开发效率。</p>
</li>
</ol>
<p>总之，使用 TypeScript 在大型项目和团队中需要关注类型安全、代码组织、文档编写、代码质量控制和团队协作等方面。遵循最佳实践可以提高开发效率、减少错误，并确保代码的可维护性和可扩展性。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Vue 3</title>
    <url>/posts/ca26.html</url>
    <content><![CDATA[<p><strong>课程计划：Vue 3</strong></p>
<ol>
<li>模块 1: Vue 3基础<ul>
<li>介绍Vue 3和其核心概念</li>
<li>学习如何创建和注册Vue组件</li>
<li>探索Vue指令和生命周期钩子函数</li>
</ul>
</li>
<li>模块 2: Vue 3的响应式系统和数据处理<ul>
<li>理解Vue 3的响应式数据和计算属性</li>
<li>学习如何处理表单输入和事件处理</li>
<li>探索Vue 3中的条件渲染和列表渲染</li>
</ul>
</li>
<li>模块 3: Vue 3高级特性<ul>
<li>深入了解Vue 3的组合式API（Composition API）</li>
<li>学习如何使用Vue Router实现路由功能</li>
<li>探索状态管理和使用Vuex</li>
</ul>
</li>
<li>模块 4: Vue 3性能优化和最佳实践<ul>
<li>学习Vue 3中的性能优化技巧和最佳实践</li>
<li>探讨Vue 3常见问题解决方法</li>
<li>最后的项目实践和总结</li>
</ul>
</li>
</ol>
<span id="more"></span>

<h1 id="Vue-3基础"><a href="#Vue-3基础" class="headerlink" title="Vue 3基础"></a>Vue 3基础</h1><h2 id="一、Vue-3核心概念"><a href="#一、Vue-3核心概念" class="headerlink" title="一、Vue 3核心概念"></a>一、Vue 3核心概念</h2><h3 id="1-组件化"><a href="#1-组件化" class="headerlink" title="1.组件化"></a>1.组件化</h3><p>Vue 3将应用程序拆分为可重用和自包含的组件。组件是Vue应用程序的基本构建块，每个组件都有自己的模板、逻辑和样式。通过组合不同的组件，您可以构建复杂的用户界面。</p>
<p><strong>组件</strong></p>
<p>在Vue中，组件是可重用的、自包含的代码模块，用于构建用户界面的一部分。组件可以包含模板、样式和逻辑，并可以在其他组件中使用。</p>
<p><strong>单文件组件</strong></p>
<p>Vue 3推荐使用单文件组件（.vue文件）的方式来编写组件。单文件组件将模板、样式和逻辑放在同一个文件中，使得组件的开发更加直观和方便。</p>
<p><strong>组件通信</strong></p>
<p>在一个大型应用程序中，不同组件之间需要进行通信和数据传递。Vue 3提供了多种方式来实现组件之间的通信，包括Props和事件系统。</p>
<ul>
<li><p>Props：通过Props（属性）将数据从父组件传递给子组件。父组件可以在使用子组件时通过属性的方式传递数据，并在子组件内部使用这些数据。</p>
</li>
<li><p>事件系统：子组件可以通过触发自定义事件来通知父组件发生了某些事情。父组件可以监听这些事件，并在事件发生时执行相应的操作。</p>
</li>
</ul>
<p><strong>组件生命周期</strong></p>
<p>每个Vue组件都有自己的生命周期，它定义了组件在创建、更新和销毁等不同阶段会触发的钩子函数。通过生命周期钩子函数，您可以在特定的阶段执行自定义的代码逻辑。</p>
<p><strong>组件的复用和组合</strong></p>
<p>组件化使得组件的复用和组合变得简单。您可以将多个小型组件组合在一起，形成更复杂的组件，从而实现界面的模块化和可重用性。</p>
<h3 id="2-响应式数据"><a href="#2-响应式数据" class="headerlink" title="2.响应式数据"></a>2.响应式数据</h3><p>Vue 3引入了一个新的响应式系统，称为”Reactivity”。它使得数据的变化可以自动地更新视图，从而实现了数据和视图的实时同步。您可以使用Vue的<code>data</code>选项或<code>ref</code>函数来定义响应式数据。</p>
<p>在Vue 3中，您可以通过以下方式创建响应式数据：</p>
<ol>
<li><p>数据属性：在组件的数据选项中，您可以声明各种数据属性。这些属性可以通过Vue的响应式系统进行跟踪，从而在数据发生变化时自动更新视图。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Hello, Vue!&#x27;</span>,</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算属性：计算属性是一种根据现有数据派生出新值的属性。它们会根据依赖的数据进行缓存，只有在依赖发生变化时才重新计算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">      <span class="attr">lastName</span>: <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">fullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在模板中可以直接访问计算属性，例如：<code>&#123;&#123; fullName &#125;&#125;</code>。</p>
</li>
<li><p>监听属性：您可以使用<code>watch</code>选项监听数据的变化，并在数据发生变化时执行相应的操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Hello, Vue!&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="title function_">message</span>(<span class="params">newMessage</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message changed to:&#x27;</span>, newMessage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>响应式数组和对象：Vue 3还提供了一些方法来处理响应式的数组和对象，例如<code>ref</code>、<code>reactive</code>、<code>toRefs</code>等。这些方法使得对数组和对象的修改也能触发视图的更新。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建响应式变量</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> user = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将响应式对象转换为响应式引用</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = <span class="title function_">toRefs</span>(user);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>响应式数据是Vue 3中非常强大和重要的特性之一。它使得数据的变化能够自动地驱动应用程序的更新，简化了开发流程并提高了代码的可维护性。</p>
<h3 id="3-虚拟DOM"><a href="#3-虚拟DOM" class="headerlink" title="3.虚拟DOM"></a>3.虚拟DOM</h3><p>Vue 3使用虚拟DOM（Virtual DOM）来高效地更新和渲染界面。虚拟DOM是一个轻量级的JavaScript对象，它表示真实DOM的一种抽象。Vue通过比较虚拟DOM的差异，并只更新必要的部分，来实现快速的页面重新渲染。</p>
<p>虚拟DOM的工作流程如下：</p>
<ol>
<li>当Vue组件的数据发生变化时，Vue会重新渲染组件，并生成一个新的虚拟DOM树。</li>
<li>Vue会将新的虚拟DOM树与旧的虚拟DOM树进行比较，找出两者之间的差异。</li>
<li>Vue会根据差异生成一系列DOM操作指令，如添加、删除、修改等。</li>
<li>Vue将这些DOM操作指令应用到实际的DOM上，完成DOM的更新。</li>
</ol>
<p>通过使用虚拟DOM，Vue能够高效地处理组件的更新，只更新必要的部分，避免不必要的DOM操作，从而提升应用程序的性能。</p>
<h3 id="4-模板语法"><a href="#4-模板语法" class="headerlink" title="4.模板语法"></a>4.模板语法</h3><p>Vue 3使用基于HTML的模板语法，允许您将Vue指令和表达式嵌入到模板中。模板语法使得编写动态、交互性的界面变得简单直观。</p>
<p>Vue 3的模板语法与Vue 2中的模板语法基本相同，但在一些细节和新增功能方面有一些改进和扩展。以下是Vue 3中常用的模板语法特性：</p>
<ol>
<li><p>插值：使用双大括号<code>&#123;&#123; &#125;&#125;</code>进行文本插值，可以将数据动态地渲染到模板中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>表达式：在插值中可以使用JavaScript表达式，进行计算和逻辑操作。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count * 2 &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指令：Vue提供了一系列的指令，以<code>v-</code>开头，用于在模板中添加特殊的行为和功能。</p>
<ul>
<li><code>v-if</code>和<code>v-else</code>：条件渲染，根据条件决定是否显示元素。</li>
<li><code>v-for</code>：列表渲染，根据数组的数据进行循环渲染元素。</li>
<li><code>v-bind</code>或简写为<code>:</code>：属性绑定，动态地绑定元素的属性。</li>
<li><code>v-on</code>或简写为<code>@</code>：事件绑定，监听元素的事件。</li>
<li><code>v-model</code>：双向数据绑定，实现表单元素与数据的双向绑定。</li>
<li>其他指令如<code>v-show</code>、<code>v-text</code>、<code>v-html</code>等。</li>
</ul>
</li>
<li><p>计算属性：使用<code>computed</code>关键字定义计算属性，用于根据数据的变化动态计算衍生的属性值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">lastName</span>: <span class="string">&#x27;Doe&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fullName</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法调用：可以直接在模板中调用组件实例中定义的方法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">count</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">count</span>++;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些是Vue 3中常用的模板语法特性，用于实现动态数据绑定、条件渲染、列表渲染、事件处理等功能。除了上述特性外，Vue 3还引入了一些新的功能，如<code>&lt;teleport&gt;</code>、<code>&lt;suspense&gt;</code>、<code>&lt;fragment&gt;</code>等，用于更好地控制组件的渲染和异步加载。</p>
<p>如果您有更具体的问题或需要了解更多细节，请随时提问。</p>
<h3 id="5-组合式API"><a href="#5-组合式API" class="headerlink" title="5.组合式API"></a>5.组合式API</h3><p>Vue 3引入了组合式API（Composition API），它是一种新的API风格，使得组件的逻辑更易于理解、组织和复用。通过使用组合式API，您可以将相关的逻辑组合在一起，形成自定义的逻辑组合块。</p>
<p>传统的Options API将组件的逻辑分散在不同的选项（如<code>data</code>、<code>methods</code>、<code>computed</code>等）中，当组件逻辑复杂时，代码可能变得难以维护和理解。而组合式API通过将逻辑按功能进行组合，使得代码更具可读性和可维护性。</p>
<p>组合式API基于函数，允许我们使用<code>setup</code>函数来编写组件的逻辑。<code>setup</code>函数在组件创建之前执行，并在组件内部暴露一些可用的功能，如<code>props</code>、<code>data</code>、<code>methods</code>等。</p>
<p>使用组合式API，我们可以将相关的功能逻辑封装为可复用的函数，并在<code>setup</code>函数中调用这些函数，从而将逻辑聚合在一起。这样做的好处是可以更方便地复用和测试逻辑，也更容易理解和维护。</p>
<p>组合式API还引入了一些新的函数，如<code>ref</code>、<code>reactive</code>、<code>computed</code>等，用于处理响应式数据。<code>ref</code>用于将普通的JavaScript值包装成响应式对象，<code>reactive</code>用于将整个对象转换为响应式对象，<code>computed</code>用于定义计算属性等。这些函数使得处理数据更加灵活和直观。</p>
<p>除了更好的逻辑组织和响应式处理，组合式API还提供了其他一些功能，如<code>watch</code>、<code>provide</code>和<code>inject</code>等，用于处理副作用、跨组件通信等。</p>
<p>总之，组合式API是Vue 3中的一项重要特性，它提供了更灵活和可组合的方式来编写组件逻辑。通过将相关的功能逻辑组合在一起，使得代码更具可读性、可维护性和可测试性。如果您习惯了传统的Options API，学习和使用组合式API可能需要一些时间适应，但它能够带来更好的开发体验和代码质量。</p>
<h3 id="6-生命周期钩子"><a href="#6-生命周期钩子" class="headerlink" title="6.生命周期钩子"></a>6.生命周期钩子</h3><p>Vue 3提供了一系列的生命周期钩子函数，用于在组件生命周期的不同阶段执行特定的操作。通过这些钩子函数，您可以在组件创建、更新和销毁的过程中插入自定义逻辑。</p>
<p>以下是Vue 3中常用的Composition API钩子函数：</p>
<ol>
<li><p><code>setup</code>：在组件实例被创建之前调用，用于设置组件的初始状态和响应式数据。可以返回一个对象，包含组件的数据、方法等内容。</p>
</li>
<li><p><code>onBeforeMount</code>：在组件挂载到DOM之前调用。</p>
</li>
<li><p><code>onMounted</code>：在组件挂载到DOM后调用。</p>
</li>
<li><p><code>onBeforeUpdate</code>：在组件更新之前调用。</p>
</li>
<li><p><code>onUpdated</code>：在组件更新之后调用。</p>
</li>
<li><p><code>onBeforeUnmount</code>：在组件卸载之前调用。</p>
</li>
<li><p><code>onUnmounted</code>：在组件卸载之后调用。</p>
</li>
<li><p><code>onErrorCaptured</code>：在子孙组件发生错误时被调用。</p>
</li>
</ol>
<p>这些钩子函数可以通过在<code>setup</code>函数中返回一个对象来使用，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUnmounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在组件挂载到DOM后执行</span></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component mounted&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在组件卸载之前执行</span></span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component unmounted&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回组件的数据、方法等</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，Vue 3中的Composition API并不强制使用特定的钩子函数，而是提供了更灵活的函数式编程方式，使开发者可以根据需求自由组合和使用不同的钩子函数。</p>
<h2 id="二、创建和注册Vue组件"><a href="#二、创建和注册Vue组件" class="headerlink" title="二、创建和注册Vue组件"></a>二、创建和注册Vue组件</h2><p>在Vue 3中，创建和注册组件非常简单。下面是创建和注册Vue组件的步骤：</p>
<h3 id="1-创建组件文件"><a href="#1-创建组件文件" class="headerlink" title="1.创建组件文件"></a>1.创建组件文件</h3><p>创建一个以<code>.vue</code>为后缀的单文件组件文件，例如<code>MyComponent.vue</code>。</p>
<h3 id="2-定义组件"><a href="#2-定义组件" class="headerlink" title="2.定义组件"></a>2.定义组件</h3><p>在组件文件中，使用<code>&lt;template&gt;</code>、<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>标签定义组件的模板、逻辑和样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 组件的模板内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 组件的逻辑代码</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="comment">/* 组件的样式 */</span></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-导入和注册组件"><a href="#3-导入和注册组件" class="headerlink" title="3.导入和注册组件"></a>3.导入和注册组件</h3><ol>
<li><p>在需要使用组件的地方，导入组件文件并使用<code>app.component</code>方法进行全局或局部注册。</p>
</li>
<li><p>全局注册：在应用的入口文件（通常是<code>main.js</code>）中，使用<code>app.component</code>方法全局注册组件。</p>
</li>
</ol>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>();</span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;my-component&#x27;</span>, <span class="title class_">MyComponent</span>);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>  在模板中使用全局注册的组件：</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>局部注册：在组件所属的父组件中，使用<code>components</code>选项局部注册组件。</li>
</ol>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ParentComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&#x27;my-component&#x27;</span>: <span class="title class_">MyComponent</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-使用组件"><a href="#4-使用组件" class="headerlink" title="4.使用组件"></a>4.使用组件</h3><ol>
<li>现在您可以在其他组件的模板中使用已注册的组件。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- OtherComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上是在Vue 3中创建和注册组件的基本步骤。您可以根据需要在组件中定义属性、方法、计算属性等，以及使用组件间的通信方式，如Props、事件、Provide&#x2F;Inject等。</p>
<p>让我们逐个介绍这些通信方式的用法：</p>
<ol>
<li><p>Props（属性传递）：</p>
<ul>
<li>父组件通过属性向子组件传递数据。</li>
<li>子组件通过在<code>props</code>选项中声明属性来接收父组件传递的数据。</li>
</ul>
<p>在父组件中使用子组件时，通过给子组件的属性赋值来传递数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ParentComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span> <span class="attr">:message</span>=<span class="string">&quot;parentMessage&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildComponent.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&#x27;child-component&#x27;</span>: <span class="title class_">ChildComponent</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">parentMessage</span>: <span class="string">&#x27;Hello from parent!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在子组件中使用<code>props</code>接收父组件传递的数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ChildComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">props</span>: [<span class="string">&#x27;message&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>事件（自定义事件）：</p>
<ul>
<li>子组件通过<code>$emit</code>方法触发自定义事件，并向父组件传递数据。</li>
<li>父组件通过在子组件上使用<code>v-on</code>指令监听自定义事件，并在相应的方法中处理数据。</li>
</ul>
<p>在子组件中使用<code>$emit</code>触发自定义事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ChildComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sendMessage&quot;</span>&gt;</span>Send Message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">sendMessage</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;message-sent&#x27;</span>, <span class="string">&#x27;Hello from child!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在父组件中使用<code>v-on</code>监听子组件的自定义事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ParentComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span> @<span class="attr">message-sent</span>=<span class="string">&quot;handleMessage&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildComponent.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&#x27;child-component&#x27;</span>: <span class="title class_">ChildComponent</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">handleMessage</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message received:&#x27;</span>, message);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Provide&#x2F;Inject（依赖注入）：</p>
<ul>
<li>父组件通过<code>provide</code>选项提供数据或方法。</li>
<li>子组件通过<code>inject</code>选项注入父组件提供的数据或方法。</li>
</ul>
<p>在父组件中使用<code>provide</code>提供数据或方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ParentComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">provide</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">message</span>: <span class="string">&#x27;Hello from parent!&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">showMessage</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在子组件中使用</p>
</li>
</ol>
<p><code>inject</code>注入父组件提供的数据或方法：</p>
   <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ChildComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">inject</span>: [<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;showMessage&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">showMessage</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这些是Vue 3中常用的组件间通信方式。您可以根据具体的场景选择适合的通信方式。注意，Provide&#x2F;Inject在跨级组件通信时非常有用，但也容易导致组件之间的耦合，因此应谨慎使用。</p>
<p>希望这能帮助您理解组件间的通信方式。如果您有更多问题，请随时提问！</p>
<p>在Vue 3中，您可以使用以下几种方式进行组件间的通信：Props、事件、Provide&#x2F;Inject。让我们逐个介绍这些通信方式的用法：</p>
<ol>
<li><p>Props（属性传递）：</p>
<ul>
<li>父组件通过属性向子组件传递数据。</li>
<li>子组件通过在<code>props</code>选项中声明属性来接收父组件传递的数据。</li>
</ul>
<p>在父组件中使用子组件时，通过给子组件的属性赋值来传递数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ParentComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span> <span class="attr">:message</span>=<span class="string">&quot;parentMessage&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildComponent.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&#x27;child-component&#x27;</span>: <span class="title class_">ChildComponent</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">parentMessage</span>: <span class="string">&#x27;Hello from parent!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在子组件中使用<code>props</code>接收父组件传递的数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ChildComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">props</span>: [<span class="string">&#x27;message&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>事件（自定义事件）：</p>
<ul>
<li>子组件通过<code>$emit</code>方法触发自定义事件，并向父组件传递数据。</li>
<li>父组件通过在子组件上使用<code>v-on</code>指令监听自定义事件，并在相应的方法中处理数据。</li>
</ul>
<p>在子组件中使用<code>$emit</code>触发自定义事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ChildComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sendMessage&quot;</span>&gt;</span>Send Message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">sendMessage</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;message-sent&#x27;</span>, <span class="string">&#x27;Hello from child!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在父组件中使用<code>v-on</code>监听子组件的自定义事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ParentComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span> @<span class="attr">message-sent</span>=<span class="string">&quot;handleMessage&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildComponent.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&#x27;child-component&#x27;</span>: <span class="title class_">ChildComponent</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">handleMessage</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message received:&#x27;</span>, message);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Provide&#x2F;Inject（依赖注入）：</p>
<ul>
<li>父组件通过<code>provide</code>选项提供数据或方法。</li>
<li>子组件通过<code>inject</code>选项注入父组件提供的数据或方法。</li>
</ul>
<p>在父组件中使用<code>provide</code>提供数据或方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ParentComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">provide</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">message</span>: <span class="string">&#x27;Hello from parent!&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">showMessage</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在子组件中使用</p>
</li>
</ol>
<p><code>inject</code>注入父组件提供的数据或方法：<br>   <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ChildComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">inject</span>: [<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;showMessage&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">showMessage</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这些是Vue 3中常用的组件间通信方式。您可以根据具体的场景选择适合的通信方式。注意，Provide&#x2F;Inject在跨级组件通信时非常有用，但也容易导致组件之间的耦合，因此应谨慎使用。</p>
<h2 id="三、探索Vue指令和生命周期钩子函数"><a href="#三、探索Vue指令和生命周期钩子函数" class="headerlink" title="三、探索Vue指令和生命周期钩子函数"></a>三、探索Vue指令和生命周期钩子函数</h2><p>当使用Vue时，指令（Directives）和生命周期钩子函数（Lifecycle Hooks）是非常重要的概念。让我们逐个探索它们的作用和用法。</p>
<h3 id="1-指令（Directives）"><a href="#1-指令（Directives）" class="headerlink" title="1.指令（Directives）"></a>1.指令（Directives）</h3><p>指令是Vue中一种特殊的属性，可以附加到HTML元素上，以完成特定的DOM操作。指令使用<code>v-</code>前缀，例如<code>v-if</code>、<code>v-for</code>等。以下是一些常用的指令：</p>
<ul>
<li><code>v-bind</code>：用于动态绑定属性，可以将数据绑定到HTML元素的属性上。</li>
<li><code>v-model</code>：用于双向数据绑定，可以在表单元素和Vue实例之间实现数据的双向同步。</li>
<li><code>v-if</code>、<code>v-else</code>、<code>v-show</code>：用于条件渲染，根据表达式的值来显示或隐藏元素。</li>
<li><code>v-for</code>：用于循环渲染，根据数据源循环生成元素或组件。</li>
<li><code>v-on</code>：用于监听事件，可以执行指定的方法或触发事件处理逻辑。</li>
</ul>
<p>以下是一个示例，展示了如何使用指令：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>Hello, Vue!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">isShow</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">list</span>: [</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;Item 1&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;Item 2&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;Item 3&#x27;</span> &#125;</span></span><br><span class="line"><span class="language-javascript">      ]</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Button clicked!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-生命周期钩子函数（Lifecycle-Hooks）"><a href="#2-生命周期钩子函数（Lifecycle-Hooks）" class="headerlink" title="2.生命周期钩子函数（Lifecycle Hooks）"></a>2.生命周期钩子函数（Lifecycle Hooks）</h3><p>生命周期钩子函数是在Vue实例的生命周期中被调用的函数，可以用来在不同阶段执行特定的操作。以下是一些常用的生命周期钩子函数：</p>
<ul>
<li><code>beforeCreate</code>：实例创建之前调用，此时数据观察和事件还未初始化。</li>
<li><code>created</code>：实例创建完成后调用，可以访问数据和执行一些初始操作。</li>
<li><code>beforeMount</code>：在实例挂载到DOM之前调用，此时模板编译完成，但尚未渲染到页面。</li>
<li><code>mounted</code>：在实例挂载到DOM之后调用，此时实例已经被渲染到页面。</li>
<li><code>beforeUpdate</code>：在数据更新之前调用，此时DOM尚未重新渲染。</li>
<li><code>updated</code>：在数据更新完成后调用，此时DOM已经更新。</li>
<li>&#96;before</li>
</ul>
<p>Unmount&#96;：在实例销毁之前调用，此时实例仍然可用。</p>
<ul>
<li><code>unmounted</code>：在实例销毁之后调用，此时实例已经被完全销毁。</li>
</ul>
<p>   以下是一个示例，展示了如何使用生命周期钩子函数：<br>   <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>: <span class="string">&#x27;Hello, Vue!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component created&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component mounted&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">updated</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component updated&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">beforeUnmount</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component before unmount&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component unmounted&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这是关于Vue指令和生命周期钩子函数的简要介绍。它们在Vue中起着重要的作用，帮助您控制和操作DOM元素以及在实例的不同生命周期阶段执行逻辑。</p>
<h1 id="Vue-3的响应式系统和数据处理"><a href="#Vue-3的响应式系统和数据处理" class="headerlink" title="Vue 3的响应式系统和数据处理"></a>Vue 3的响应式系统和数据处理</h1><h2 id="一、Vue-3的响应式数据和计算属性"><a href="#一、Vue-3的响应式数据和计算属性" class="headerlink" title="一、Vue 3的响应式数据和计算属性"></a>一、Vue 3的响应式数据和计算属性</h2><p>在Vue 3中，响应式数据是指通过Vue的响应式系统实现数据与视图之间的自动关联和更新。Vue 3引入了<code>reactive</code>函数和<code>ref</code>函数来创建响应式数据。</p>
<h3 id="1-响应式数据"><a href="#1-响应式数据" class="headerlink" title="1.响应式数据"></a>1.响应式数据</h3><ul>
<li><code>reactive</code>函数：<code>reactive</code>函数接收一个普通的JavaScript对象，并返回一个响应式的代理对象。通过使用<code>reactive</code>函数，我们可以将对象的属性转化为响应式数据，当属性的值发生改变时，相关的视图将自动更新。</li>
</ul>
<p>以下是一个示例，展示如何使用<code>reactive</code>函数创建响应式数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">message</span>: <span class="string">&#x27;Hello, Vue!&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问响应式数据</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">message</span>); <span class="comment">// 输出: Hello, Vue!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改响应式数据</span></span><br><span class="line">state.<span class="property">message</span> = <span class="string">&#x27;Vue 3 is awesome!&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">message</span>); <span class="comment">// 输出: Vue 3 is awesome!</span></span><br></pre></td></tr></table></figure>

<h3 id="2-计算属性"><a href="#2-计算属性" class="headerlink" title="2.计算属性"></a>2.计算属性</h3><p>计算属性是一种通过对其他响应式数据进行计算得出结果的方式。在Vue 3中，我们可以使用<code>computed</code>函数来创建计算属性。</p>
<p>以下是一个示例，展示如何使用<code>computed</code>函数创建计算属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fullName = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;state.firstName&#125;</span> <span class="subst">$&#123;state.lastName&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问计算属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullName.<span class="property">value</span>); <span class="comment">// 输出: John Doe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改依赖属性</span></span><br><span class="line">state.<span class="property">firstName</span> = <span class="string">&#x27;Jane&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullName.<span class="property">value</span>); <span class="comment">// 输出: Jane Doe</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个计算属性<code>fullName</code>，它依赖于<code>state</code>对象中的<code>firstName</code>和<code>lastName</code>属性。当<code>firstName</code>或<code>lastName</code>发生改变时，<code>fullName</code>将自动重新计算。</p>
<p>通过使用响应式数据和计算属性，Vue 3使得数据的响应性和派生状态的管理更加灵活和高效。您可以根据需要创建响应式的数据对象，并通过计算属性生成派生的数据，以满足复杂的业务逻辑需求。</p>
<h2 id="二、处理表单输入和事件处理"><a href="#二、处理表单输入和事件处理" class="headerlink" title="二、处理表单输入和事件处理"></a>二、处理表单输入和事件处理</h2><p>在Vue 3中处理表单输入和事件处理非常简单。您可以使用<code>v-model</code>指令来实现表单输入的双向绑定，同时可以使用<code>@</code>或<code>v-on</code>指令来监听和处理事件。</p>
<h3 id="1-表单输入："><a href="#1-表单输入：" class="headerlink" title="1.表单输入："></a>1.表单输入：</h3><ul>
<li><p>文本输入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码将<code>&lt;input&gt;</code>元素与Vue实例的<code>message</code>属性进行双向绑定，输入框中的值将自动同步到<code>message</code>属性中。</p>
</li>
<li><p>多行文本输入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>类似地，<code>&lt;textarea&gt;</code>元素也可以使用<code>v-model</code>指令进行双向绑定。</p>
</li>
<li><p>复选框：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;isChecked&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>v-model</code>指令可以将复选框的选中状态与Vue实例的属性进行绑定。</p>
</li>
<li><p>单选框：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;selectedOption&quot;</span> <span class="attr">value</span>=<span class="string">&quot;option1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;selectedOption&quot;</span> <span class="attr">value</span>=<span class="string">&quot;option2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在一组单选框中，可以使用相同的<code>v-model</code>指令，并为每个单选框设置不同的<code>value</code>值，选中的值将存储在Vue实例的属性中。</p>
</li>
<li><p>下拉框：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selectedOption&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;option1&quot;</span>&gt;</span>Option 1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;option2&quot;</span>&gt;</span>Option 2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过<code>v-model</code>指令，可以将下拉框的选中值与Vue实例的属性进行绑定。</p>
</li>
</ul>
<h3 id="2-事件处理："><a href="#2-事件处理：" class="headerlink" title="2.事件处理："></a>2.事件处理：</h3><p>使用<code>@</code>或<code>v-on</code>指令可以监听和处理各种事件，例如点击事件、键盘事件等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在Vue实例中定义事件处理方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 处理点击事件的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以将事件对象作为方法参数进行访问，以获取事件的详细信息：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick($event)&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在Vue实例中处理事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">handleClick</span>(<span class="params">event</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>); <span class="comment">// 输出点击事件的目标元素</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述方式，您可以轻松地处理表单输入和各种事件，实现与用户的交互。在Vue 3中，通过简洁的语法和灵活的指令，您可以高效地编写表单和事件处理逻辑。</p>
<h2 id="三、探索Vue-3中的条件渲染和列表渲染"><a href="#三、探索Vue-3中的条件渲染和列表渲染" class="headerlink" title="三、探索Vue 3中的条件渲染和列表渲染"></a>三、探索Vue 3中的条件渲染和列表渲染</h2><p>在Vue 3中，条件渲染和列表渲染是常用的功能，可以帮助您根据特定条件或数据列表动态地渲染和更新DOM。</p>
<h3 id="1-条件渲染："><a href="#1-条件渲染：" class="headerlink" title="1.条件渲染："></a>1.条件渲染：</h3><p>使用<code>v-if</code>指令可以根据表达式的真假值来条件性地渲染DOM元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;isVisible&quot;</span>&gt;</span>This paragraph is visible.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，只有当<code>isVisible</code>属性为真时，<code>&lt;p&gt;</code>元素才会被渲染到DOM中。</p>
<p>除了<code>v-if</code>，还可以使用<code>v-else</code>和<code>v-else-if</code>指令来实现条件渲染的分支逻辑。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;condition&quot;</span>&gt;</span>Condition is true.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else-if</span>=<span class="string">&quot;otherCondition&quot;</span>&gt;</span>Other condition is true.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>Neither condition is true.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，根据不同的条件，将渲染不同的段落。</p>
<h3 id="2-列表渲染："><a href="#2-列表渲染：" class="headerlink" title="2.列表渲染："></a>2.列表渲染：</h3><p>使用<code>v-for</code>指令可以根据数据列表进行循环渲染。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in itemList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>itemList</code>是一个包含多个对象的数组，通过<code>v-for</code>指令可以将数组中的每个对象渲染为一个列表项(<code>&lt;li&gt;</code>)，<code>:key</code>用于指定每个列表项的唯一标识，以便Vue能够高效地进行更新。</p>
<p>除了遍历数组，您还可以使用<code>v-for</code>指令遍历对象的属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key) in objectData&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;key&quot;</span>&gt;</span>&#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>objectData</code>是一个包含多个属性的对象，通过<code>v-for</code>指令可以遍历对象的属性并将其渲染为列表项(<code>&lt;li&gt;</code>)，<code>key</code>表示属性名，<code>value</code>表示属性值。</p>
<p>除了基本的遍历，<code>v-for</code>指令还支持索引、迭代状态和范围循环等高级用法，以满足更复杂的需求。</p>
<p>通过条件渲染和列表渲染，您可以根据数据的动态变化来动态地更新和呈现DOM内容。这使得在Vue 3中处理各种动态渲染场景变得更加简单和灵活。</p>
<h1 id="Vue-3高级特性"><a href="#Vue-3高级特性" class="headerlink" title="Vue 3高级特性"></a>Vue 3高级特性</h1><h2 id="一、深入了解Vue-3的组合式API（Composition-API）"><a href="#一、深入了解Vue-3的组合式API（Composition-API）" class="headerlink" title="一、深入了解Vue 3的组合式API（Composition API）"></a>一、深入了解Vue 3的组合式API（Composition API）</h2><p>Vue 3引入了组合式API（Composition API），它提供了一种新的组织和复用Vue组件逻辑的方式。相比于传统的选项式API，组合式API更加灵活和可维护，使开发者能够更好地组织和管理组件的代码。</p>
<p>以下是组合式API的一些重要概念和特性：</p>
<h3 id="1-Composition函数"><a href="#1-Composition函数" class="headerlink" title="1.Composition函数"></a>1.Composition函数</h3><p>组合式API的核心是通过Composition函数来定义组件的逻辑。一个Composition函数是一个普通的JavaScript函数，可以包含状态、计算属性、方法和生命周期钩子等组件逻辑。通过使用多个Composition函数，可以将组件逻辑划分为更小的可复用部分。</p>
<p>在Vue 3中，通过使用<code>setup</code>函数来配置和使用Composition函数。<code>setup</code>函数在组件实例创建之前执行，并接收两个参数：<code>props</code>和<code>context</code>。在<code>setup</code>函数中，可以访问和操作组件的props，并返回一个包含组合式逻辑的对象。</p>
<p>下面是一个示例，演示了如何使用Composition函数和<code>setup</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useCounter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 定义响应式状态</span></span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义计算属性</span></span><br><span class="line">  <span class="keyword">const</span> doubleCount = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义方法</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    count.<span class="property">value</span>++;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    count.<span class="property">value</span>--;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在组件实例销毁时执行的生命周期钩子</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onUnmounted</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Counter组件销毁了&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回包含逻辑的对象</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count,</span><br><span class="line">    doubleCount,</span><br><span class="line">    increment,</span><br><span class="line">    decrement,</span><br><span class="line">    onUnmounted</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 调用useCounter函数获取逻辑对象</span></span><br><span class="line">    <span class="keyword">const</span> counter = <span class="title function_">useCounter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回逻辑对象，使其在组件内部可用</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...counter</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>useCounter</code>是一个Composition函数，定义了计数器组件的逻辑。在<code>setup</code>函数中，我们调用了<code>useCounter</code>函数来获取逻辑对象，并通过展开语法将其返回，使其在组件内部可用。</p>
<p>通过使用Composition函数，我们可以将组件的逻辑划分为更小的可复用部分，并通过导入和重用来实现逻辑的共享和复用。这种方式使得组件的逻辑更加清晰、可读性更强，并且更容易进行单元测试和维护。</p>
<h3 id="2-setup函数"><a href="#2-setup函数" class="headerlink" title="2.setup函数"></a>2.setup函数</h3><p>在组件内部使用<code>setup</code>函数来定义和配置Composition函数。<code>setup</code>函数在组件实例创建之前执行，并接收两个参数：<code>props</code>和<code>context</code>。在<code>setup</code>函数中，可以访问和操作组件的props，以及通过<code>context</code>参数获取组件的上下文信息，例如<code>attrs</code>、<code>slots</code>、<code>emit</code>等。</p>
<p><code>setup</code>函数可以返回一个对象，该对象中包含了组件的数据、方法、计算属性等等。这些数据和方法将在组件的模板中可用，并且会自动进行响应式处理。</p>
<p>下面是一个示例，演示了<code>setup</code>函数的用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, reactive, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">initialCount</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="comment">// 定义响应式数据</span></span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(props.<span class="property">initialCount</span>);</span><br><span class="line">    <span class="keyword">const</span> message = <span class="title function_">reactive</span>(&#123; <span class="attr">text</span>: <span class="string">&#x27;Hello, Vue 3!&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义计算属性</span></span><br><span class="line">    <span class="keyword">const</span> doubleCount = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      count.<span class="property">value</span>++;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">changeMessage</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      message.<span class="property">text</span> = <span class="string">&#x27;Vue 3 is awesome!&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问组件上下文信息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="property">attrs</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="property">slots</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="property">emit</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据和方法，使其在组件内部可用</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      doubleCount,</span><br><span class="line">      message,</span><br><span class="line">      increment,</span><br><span class="line">      changeMessage</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们在<code>setup</code>函数中定义了响应式数据<code>count</code>和<code>message</code>，计算属性<code>doubleCount</code>，以及方法<code>increment</code>和<code>changeMessage</code>。然后将这些数据和方法包装在一个对象中返回，使其在组件内部可用。</p>
<p>需要注意的是，<code>setup</code>函数是在组件实例创建之前执行的，因此在函数内部无法使用<code>this</code>来访问组件实例。如果需要访问组件实例，可以使用<code>getCurrentInstance()</code>函数来获取当前的组件实例。</p>
<p>总结而言，<code>setup</code>函数是Vue 3中用于配置组件逻辑的特殊函数，通过在函数内部定义响应式数据、计算属性和方法，并将它们返回为一个对象，可以使得这些逻辑在组件内部可用，并且会自动进行响应式处理。</p>
<h3 id="3-响应式状态"><a href="#3-响应式状态" class="headerlink" title="3.响应式状态"></a>3.响应式状态</h3><p>通过在<code>setup</code>函数中使用<code>ref</code>和<code>reactive</code>函数来创建响应式状态。<code>ref</code>用于创建单个的响应式变量，而<code>reactive</code>则用于创建一个包含多个响应式属性的对象。这些响应式状态可以在组件的模板和Composition函数中使用，并能自动追踪其依赖关系。</p>
<p><strong>状态管理</strong></p>
<p>理论上来说，每一个 Vue 组件实例都已经在“管理”它自己的响应式状态了。我们以一个简单的计数器组件为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  // 状态</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 动作</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 视图 --&gt;</span><br><span class="line">&lt;template&gt;&#123;&#123; count &#125;&#125;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>它是一个独立的单元，由以下几个部分组成：</p>
<ul>
<li><strong>状态</strong>：驱动整个应用的数据源；</li>
<li><strong>视图</strong>：对<strong>状态</strong>的一种声明式映射；</li>
<li><strong>交互</strong>：状态根据用户在<strong>视图</strong>中的输入而作出相应变更的可能方式。</li>
</ul>
<p>下面是“单向数据流”这一概念的简单图示：</p>
<p><img data-src="https://cn.vuejs.org/assets/state-flow.a8bc738e.png" alt="state flow diagram"></p>
<p>然而，当我们有<strong>多个组件共享一个共同的状态</strong>时，就没有这么简单了：</p>
<ol>
<li>多个视图可能都依赖于同一份状态。</li>
<li>来自不同视图的交互也可能需要更改同一份状态。</li>
</ol>
<p>对于情景 1，一个可行的办法是将共享状态“提升”到共同的祖先组件上去，再通过 props 传递下来。然而在深层次的组件树结构中这么做的话，很快就会使得代码变得繁琐冗长。这会导致另一个问题：<a href="https://cn.vuejs.org/guide/components/provide-inject.html#prop-drilling">Prop 逐级透传问题</a>。</p>
<p>对于情景 2，我们经常发现自己会直接通过模板引用获取父&#x2F;子实例，或者通过触发的事件尝试改变和同步多个状态的副本。但这些模式的健壮性都不甚理想，很容易就会导致代码难以维护。</p>
<p>一个更简单直接的解决方案是抽取出组件间的共享状态，放在一个全局单例中来管理。这样我们的组件树就变成了一个大的“视图”，而任何位置上的组件都可以访问其中的状态或触发动作。</p>
<p><strong>用响应式 API做简单状态管理</strong></p>
<p>在选项式 API 中，响应式数据是用 <code>data()</code> 选项声明的。在内部，<code>data()</code> 的返回值对象会通过 <a href="https://cn.vuejs.org/api/reactivity-core.html#reactive"><code>reactive()</code></a> 这个公开的 API 函数转为响应式。</p>
<p>如果你有一部分状态需要在多个组件实例间共享，你可以使用 <a href="https://cn.vuejs.org/api/reactivity-core.html#reactive"><code>reactive()</code></a> 来创建一个响应式对象，并将它导入到多个组件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- ComponentA.vue --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; store &#125; from &#x27;./store.js&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      store</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;From A: &#123;&#123; store.count &#125;&#125;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- ComponentB.vue --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; store &#125; from &#x27;./store.js&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      store</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;From B: &#123;&#123; store.count &#125;&#125;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>现在每当 <code>store</code> 对象被更改时，<code>&lt;ComponentA&gt;</code> 与 <code>&lt;ComponentB&gt;</code> 都会自动更新它们的视图。现在我们有了单一的数据源。</p>
<p>然而，这也意味着任意一个导入了 <code>store</code> 的组件都可以随意修改它的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;store.count++&quot;&gt;</span><br><span class="line">    From B: &#123;&#123; store.count &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>虽然这在简单的情况下是可行的，但从长远来看，可以被任何组件任意改变的全局状态是不太容易维护的。为了确保改变状态的逻辑像状态本身一样集中，建议在 store 上定义方法，方法的名称应该要能表达出行动的意图：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;store.increment()&quot;&gt;</span><br><span class="line">    From B: &#123;&#123; store.count &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>请注意这里点击的处理函数使用了 <code>store.increment()</code>，带上了圆括号作为内联表达式调用，因为它并不是组件的方法，并且必须要以正确的 <code>this</code> 上下文来调用。</p>
<p>除了我们这里用到的单个响应式对象作为一个 store 之外，你还可以使用其他<a href="https://cn.vuejs.org/api/reactivity-core.html">响应式 API</a> 例如 <code>ref()</code> 或是 <code>computed()</code>，或是甚至通过一个<a href="https://cn.vuejs.org/guide/reusability/composables.html">组合式函数</a>来返回一个全局状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局状态，创建在模块作用域下</span></span><br><span class="line"><span class="keyword">const</span> globalCount = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 局部状态，每个组件都会创建</span></span><br><span class="line">  <span class="keyword">const</span> localCount = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    globalCount,</span><br><span class="line">    localCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，Vue 的响应性系统与组件层是解耦的，这使得它非常灵活。</p>
<h3 id="4-计算属性和监听器"><a href="#4-计算属性和监听器" class="headerlink" title="4.计算属性和监听器"></a>4.计算属性和监听器</h3><p>使用<code>computed</code>函数可以定义计算属性，它接受一个计算函数，并返回一个响应式的计算属性对象。计算属性可以根据其他响应式状态进行计算，并在其依赖发生变化时自动更新。另外，使用<code>watch</code>函数可以定义一个监听器，它可以观察响应式状态的变化并执行相应的操作。</p>
<h3 id="5-方法"><a href="#5-方法" class="headerlink" title="5.方法"></a>5.方法</h3><p>在Composition函数中定义的方法可以在模板中进行调用。与选项式API不同，不需要将方法放在特定的选项中，而是直接在Composition函数中定义即可。</p>
<h3 id="6-生命周期钩子-1"><a href="#6-生命周期钩子-1" class="headerlink" title="6.生命周期钩子"></a>6.生命周期钩子</h3><p>组合式API提供了类似于选项式API的生命周期钩子函数，例如<code>onMounted</code>、<code>onUpdated</code>和<code>onUnmounted</code>等。这些钩子函数可以在组件的不同生命周期阶段执行相应的操作。</p>
<h3 id="7-自定义逻辑复用"><a href="#7-自定义逻辑复用" class="headerlink" title="7.自定义逻辑复用"></a>7.自定义逻辑复用</h3><p>使用组合式API，可以将相关的逻辑封装在Composition函数中，并通过导入和重用来实现逻辑的共享和复用。这种方式使得代码更具可读性和可维护性。</p>
<p>通过组合式API，Vue 3提供了更灵活、可组合和可维护的方式来组织和管理组件逻辑。它使开发者能够更好地重用逻辑、抽象组件，并更清晰地表达组件的功能。</p>
<h2 id="二、使用Vue-Router实现路由功能"><a href="#二、使用Vue-Router实现路由功能" class="headerlink" title="二、使用Vue Router实现路由功能"></a>二、使用Vue Router实现路由功能</h2><h3 id="1-安装Vue-Router并配置路由"><a href="#1-安装Vue-Router并配置路由" class="headerlink" title="1.安装Vue Router并配置路由"></a>1.安装Vue Router并配置路由</h3><p>首先，使用npm或yarn安装Vue Router：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> vue-router</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">yarn <span class="built_in">add</span> vue-router</span><br></pre></td></tr></table></figure>

<p>安装完成后，在Vue项目的入口文件（通常是<code>main.js</code>）中引入Vue Router并使用Vue的<code>use</code>方法将其安装到Vue应用中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>接下来，创建一个新的文件（例如<code>router.js</code>），用于配置路由。在该文件中，导入Vue Router的相关模块和需要路由的组件，然后创建一个新的Vue Router实例并配置路由映射关系：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./views/Home.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;./views/About.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Home</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">About</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),</span><br><span class="line">  routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了两个路由：<code>&#39;/&#39;</code>对应的组件是<code>Home</code>，<code>&#39;/about&#39;</code>对应的组件是<code>About</code>。可以根据需要添加更多的路由。</p>
<p>最后，将路由实例导出，以便在入口文件中使用。</p>
<p>现在，你可以在Vue组件中使用路由了。可以通过<code>&lt;router-link&gt;</code>组件创建链接，以及使用<code>&lt;router-view&gt;</code>组件来渲染匹配的组件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过<code>&lt;router-link&gt;</code>组件创建的链接会自动根据路由配置生成正确的URL，并在点击时触发路由切换。<code>&lt;router-view&gt;</code>组件会根据当前路由的路径动态渲染匹配的组件。</p>
<p>这样，你就可以在Vue应用中使用Vue Router实现路由功能了。你可以添加更多的路由和组件，定义嵌套路由、参数化路由等等，以满足你的应用需求。</p>
<h3 id="2-路由拦截"><a href="#2-路由拦截" class="headerlink" title="2.路由拦截"></a>2.路由拦截</h3><p>在Vue Router中，可以使用路由导航守卫来实现路由拦截。导航守卫允许你在路由切换前后执行一些逻辑，例如进行身份验证、权限验证、记录页面访问日志等。</p>
<p>Vue Router提供了三种导航守卫：</p>
<ol>
<li><p><strong>全局前置守卫</strong> (<code>beforeEach</code>)：在路由切换前执行，可以用来进行全局的身份验证或权限检查。</p>
</li>
<li><p><strong>全局解析守卫</strong> (<code>beforeResolve</code>)：在路由切换前执行，但在组件内的守卫之前执行。适合进行全局的异步数据加载。</p>
</li>
<li><p><strong>全局后置守卫</strong> (<code>afterEach</code>)：在路由切换后执行，用于执行一些全局的清理任务或日志记录等。</p>
</li>
</ol>
<p>下面是一个简单的示例，演示如何使用全局前置守卫进行身份验证：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./views/Home.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Dashboard</span> <span class="keyword">from</span> <span class="string">&#x27;./views/Dashboard.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123; <span class="attr">requiresAuth</span>: <span class="literal">true</span> &#125; <span class="comment">// 添加一个自定义的元字段，表示需要身份验证</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/dashboard&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Dashboard</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断是否需要身份验证</span></span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">requiresAuth</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里可以根据你的身份验证逻辑进行判断</span></span><br><span class="line">    <span class="keyword">const</span> isAuthenticated = <span class="title function_">checkAuth</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isAuthenticated) &#123;</span><br><span class="line">      <span class="comment">// 身份验证通过，继续路由切换</span></span><br><span class="line">      <span class="title function_">next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 身份验证失败，重定向到登录页或其他处理</span></span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不需要身份验证的路由直接通过</span></span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们为根路由 <code>/</code> 添加了一个 <code>requiresAuth</code> 的元字段，并在全局前置守卫中进行了身份验证逻辑。如果用户访问需要身份验证的路由时未通过身份验证，我们将其重定向到登录页或其他处理。</p>
<p>你还可以使用其他导航守卫来执行其他类型的路由拦截和逻辑，例如在全局解析守卫中进行异步数据加载，或在全局后置守卫中执行清理任务。</p>
<p>通过使用路由导航守卫，你可以对路由进行拦截并执行相应的逻辑，以满足你的应用需求。你可以根据实际情况组合使用不同的导航守卫，并根据路由的元字段或其他条件进行判断和处理。</p>
<h2 id="三、探索状态管理和使用Vuex"><a href="#三、探索状态管理和使用Vuex" class="headerlink" title="三、探索状态管理和使用Vuex"></a>三、探索状态管理和使用Vuex</h2><p>在Vue.js中，Vuex是一种状态管理模式和库，用于集中管理应用程序的状态。它与Vue的响应式系统紧密集成，提供了一种可预测和可维护的方式来管理应用程序的状态，并实现组件之间的通信。</p>
<p><img data-src="https://vuex.vuejs.org/vuex.png" alt="数据流程图"></p>
<p>改图通俗来讲就是前端组件发送数据调用后端产生突变（即改变某个状态，该状态可以由Devtools改变）然后表现在前端的页面上。</p>
<p>下面是使用Vuex的一般步骤：</p>
<h3 id="1-安装和设置Vuex"><a href="#1-安装和设置Vuex" class="headerlink" title="1.安装和设置Vuex"></a>1.安装和设置Vuex</h3><p>首先，你需要使用npm或yarn安装Vuex库。然后，在你的Vue应用的入口文件中（通常是main.js），导入Vuex并通过Vue.use()方法安装它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Vuex store实例并传入配置</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="comment">// 配置选项</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(store);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-定义状态和突变"><a href="#2-定义状态和突变" class="headerlink" title="2.定义状态和突变"></a>2.定义状态和突变</h3><p>在Vuex中，状态存储在一个称为store的中央容器中。你可以在store的配置选项中定义应用程序的状态和突变（mutations）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">//突变</span></span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">decrement</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们定义了一个名为count的状态和两个突变（increment和decrement），用于增加和减少count的值。</p>
<h3 id="3-使用状态"><a href="#3-使用状态" class="headerlink" title="3.使用状态"></a>3.使用状态</h3><p>在Vue组件中，可以通过<code>this.$store.state</code>访问Vuex store中的状态。例如，你可以在组件的模板中使用双花括号插值语法来显示状态的值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;&#123; $store.state.count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">decrement</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;decrement&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们使用<code>this.$store.state.count</code>访问状态值，并通过<code>this.$store.commit</code>调用突变来修改状态。</p>
<h3 id="4-使用getters"><a href="#4-使用getters" class="headerlink" title="4.使用getters"></a>4.使用getters</h3><p>Vuex还提供了getters，用于派生状态或计算属性。你可以在store的配置选项中定义getters，并在组件中使用<code>this.$store.getters</code>来获取派生状态的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">decrement</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">doubleCount</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在组件中，你可以像访问状态一样使用<code>this.$store.getters</code>来获取派生状态的值。</p>
<h3 id="5-使用actions"><a href="#5-使用actions" class="headerlink" title="5.使用actions"></a>5.使用actions</h3><p>如果你需要在突变之外执行异步操作或处理复杂的逻辑，可以使用actions。你可以在store的配置选项中定义actions，并在组件中使用<code>this.$store.dispatch</code>来触发一个action。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">decrement</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      state.<span class="property">count</span>--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">incrementAsync</span>(<span class="params">context</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在组件中，你可以使用<code>this.$store.dispatch</code>来触发一个action。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;&#123; $store.state.count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;incrementAsync&quot;</span>&gt;</span>Increment Async<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">decrement</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;decrement&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">incrementAsync</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;incrementAsync&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们定义了一个名为incrementAsync的action，它在延迟1秒后调用突变来增加count的值。</p>
<p>这只是Vuex的基本用法，它还提供了更多高级功能，例如模块化、严格模式、插件等。你可以查阅Vuex的官方文档以获得更详细的信息和示例：<a href="https://vuex.vuejs.org/">Vuex官方文档</a>。</p>
<h3 id="6-Vuex的使用案例"><a href="#6-Vuex的使用案例" class="headerlink" title="6.Vuex的使用案例"></a>6.Vuex的使用案例</h3><p>1.用户权限可以存储在Vuex的store的state中。</p>
<p>Vuex是Vue的官方状态管理库，用于管理应用程序的全局状态。它提供了一个中心化的存储空间，可以在应用程序的不同组件之间共享数据。</p>
<p>在Vuex的store中，你可以创建一个用于存储用户权限的状态字段，例如<code>userPermissions</code>。当用户登录或权限发生变化时，你可以更新<code>userPermissions</code>的值。其他组件可以通过在计算属性或方法中访问<code>userPermissions</code>来获取用户的权限信息。</p>
<p>以下是一个示例Vuex store的代码：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeimport &#123; createStore &#125; <span class="keyword">from</span> &#x27;vuex&#x27;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(&#123;</span><br><span class="line">  <span class="keyword">state</span>: &#123;</span><br><span class="line">    <span class="keyword">user</span>Permissions: []</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="built_in">set</span>UserPermissions(<span class="keyword">state</span>, permissions) &#123;</span><br><span class="line">      <span class="keyword">state</span>.<span class="keyword">user</span>Permissions = permissions</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    updateUserPermissions(&#123; commit &#125;, permissions) &#123;</span><br><span class="line">      // 在此处可以进行异步操作，例如从服务器获取权限数据</span><br><span class="line">      commit(&#x27;<span class="built_in">set</span>UserPermissions&#x27;, permissions)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    getUserPermissions(<span class="keyword">state</span>) &#123;</span><br><span class="line">      return <span class="keyword">state</span>.<span class="keyword">user</span>Permissions</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>userPermissions</code>存储在store的state中，并通过<code>setUserPermissions</code> mutation进行更新。<code>updateUserPermissions</code> action可以用于异步操作，如从服务器获取权限数据。通过<code>getUserPermissions</code> getter，其他组件可以获取<code>userPermissions</code>的值。</p>
<p>通过将用户权限存储在Vuex的store中，你可以在应用程序的任何组件中轻松访问和更新用户权限数据。这样可以实现统一的权限管理，并确保各个组件之间的数据一致性。</p>
<h1 id="Vue3常见组件依赖库"><a href="#Vue3常见组件依赖库" class="headerlink" title="Vue3常见组件依赖库"></a>Vue3常见组件依赖库</h1><ol>
<li><strong>Element Plus</strong>：一个基于Vue 3的UI组件库，提供了丰富的组件和样式，包括按钮、表单、弹窗、菜单等，适用于构建现代化的Web应用程序。</li>
<li><strong>Axios</strong>：一个基于Promise的HTTP客户端库，可用于发送HTTP请求，并处理响应数据，适用于与后端API进行数据交互。</li>
<li><strong>Ant Design Vue</strong>：一个基于Vue 3的企业级UI组件库，提供了大量的可复用组件和样式，适用于构建复杂的企业应用程序。</li>
<li><strong>Vuetify</strong>：一个基于Vue 3的Material Design组件库，提供了大量的Material Design风格的组件和样式，适用于构建美观和响应式的Web应用程序。</li>
<li><strong>Tailwind CSS</strong>：一个高度可定制的CSS框架，可以与Vue 3集成，提供了大量的CSS实用工具和组件，使样式开发更加高效和灵活。</li>
<li><strong>Buefy</strong>：一个基于Vue 3的轻量级UI组件库，提供了简洁和易用的组件，适用于快速构建简单和中小型的Web应用程序。</li>
</ol>
<h1 id="Vue-3性能优化和最佳实践"><a href="#Vue-3性能优化和最佳实践" class="headerlink" title="Vue 3性能优化和最佳实践"></a>Vue 3性能优化和最佳实践</h1><h2 id="一、学习Vue-3中的性能优化技巧和最佳实践"><a href="#一、学习Vue-3中的性能优化技巧和最佳实践" class="headerlink" title="一、学习Vue 3中的性能优化技巧和最佳实践"></a>一、学习Vue 3中的性能优化技巧和最佳实践</h2><p>在Vue 3中，以下是一些性能优化技巧和最佳实践，帮助你提高应用程序的性能：</p>
<h3 id="1-使用v-once指令"><a href="#1-使用v-once指令" class="headerlink" title="1.使用v-once指令"></a>1.使用v-once指令</h3><p>如果你知道某个组件或元素的内容不会发生变化，可以使用v-once指令将其标记为静态内容。这样可以避免不必要的重新渲染。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-once</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-避免频繁使用大量计算属性"><a href="#2-避免频繁使用大量计算属性" class="headerlink" title="2.避免频繁使用大量计算属性"></a>2.避免频繁使用大量计算属性</h3><p>计算属性在需要时会自动进行缓存，但如果计算属性的依赖项发生变化，它们仍然需要重新计算。因此，如果某个计算属性的依赖项<strong>频繁变化</strong>，可能会导致不必要的性能<strong>损失</strong>。在这种情况下，可以<strong>考虑使用普通方法</strong>来代替计算属性。</p>
<h3 id="3-合理使用v-if和v-show"><a href="#3-合理使用v-if和v-show" class="headerlink" title="3.合理使用v-if和v-show"></a>3.合理使用v-if和v-show</h3><p>v-if适用于<strong>在条件满足时渲染或销毁元素</strong>，而v-show适用于在<strong>条件满足时通过CSS控制元素的显示或隐藏</strong>。<strong>如果在切换频繁的情况下</strong>，元素的稳定性较高，可以使用<strong>v-show</strong>来<strong>避免不必要的DOM重建</strong>。</p>
<h3 id="4-使用key属性"><a href="#4-使用key属性" class="headerlink" title="4.使用key属性"></a>4.使用key属性</h3><p>在<strong>使用v-for指令渲染列表时，为每个项提供唯一的key属性</strong>。这样Vue可以跟踪每个项的标识，并且在重新渲染列表时进行更高效的更新。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-异步组件和懒加载"><a href="#5-异步组件和懒加载" class="headerlink" title="5.异步组件和懒加载"></a>5.异步组件和懒加载</h3><p>对于较大或复杂的组件，可以考虑使用异步组件和懒加载。通过将组件分割成更小的块，并根据需要延迟加载，可以提高初始加载速度和减少资源占用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">AsyncComponent</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./AsyncComponent.vue&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">AsyncComponent</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-手动控制组件更新"><a href="#6-手动控制组件更新" class="headerlink" title="6.手动控制组件更新"></a>6.手动控制组件更新</h3><p>在某些情况下，可以通过手动调用<code>forceUpdate()</code>方法来控制组件的更新。<strong>这在需要精细控制组件的渲染时特别有用</strong>，但请注意过度使用此方法可能导致不必要的性能损失。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">updateComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.$forceUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-使用合适的事件修饰符"><a href="#7-使用合适的事件修饰符" class="headerlink" title="7.使用合适的事件修饰符"></a>7.使用合适的事件修饰符</h3><p>Vue提供了许多<strong>事件修饰符</strong>，例如<code>.prevent</code>、<code>.stop</code>、<code>.capture</code>等。正确使用事件修饰符可以避免不必要的事件冒泡、默认行为和多余的事件监听器。</p>
<p>以下是一些常用的事件修饰符和它们的用法：</p>
<ul>
<li><strong>.stop</strong>：阻止事件冒泡，相当于调用了<code>event.stopPropagation()</code>。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>.prevent</strong>：阻止默认行为，相当于调用了<code>event.preventDefault()</code>。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>=<span class="string">&quot;submitForm&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>.capture</strong>：使用事件捕获模式而不是冒泡模式。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.capture</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>.self</strong>：只在事件的目标元素自身触发时才调用事件处理程序，而不是在其子元素上触发。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.self</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>.once</strong>：只触发一次事件处理程序，之后自动解绑。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>.passive</strong>：告知浏览器该事件处理程序不会调用<code>event.preventDefault()</code>，可以提升滚动性能。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">touchstart.passive</span>=<span class="string">&quot;handleTouchStart&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这些事件修饰符可以组合使用，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop.prevent</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上是一些常用的事件修饰符，根据你的具体需求和场景选择合适的事件修饰符来处理事件，以提高代码的可读性和性能。</p>
<p>这些是一些常见的性能优化技巧和最佳实践，但请记住，优化应该基于具体的应用场景和需求。在进行性能优化时，最好使用性能分析工具来评估和确定性能瓶颈，并针对性地进行优化。</p>
<h2 id="二、探讨Vue-3常见问题解决方法"><a href="#二、探讨Vue-3常见问题解决方法" class="headerlink" title="二、探讨Vue 3常见问题解决方法"></a>二、探讨Vue 3常见问题解决方法</h2><p>在使用Vue 3的过程中，可能会遇到一些常见问题。以下是一些常见问题及其解决方法：</p>
<h3 id="1-Vue组件无法正常渲染或显示"><a href="#1-Vue组件无法正常渲染或显示" class="headerlink" title="1.Vue组件无法正常渲染或显示"></a>1.Vue组件无法正常渲染或显示</h3><p>检查组件的模板语法是否正确，确保所有的标签都正确闭合，检查组件的数据是否正确传递和使用。</p>
<h3 id="2-无法访问或更新响应式数据"><a href="#2-无法访问或更新响应式数据" class="headerlink" title="2.无法访问或更新响应式数据"></a>2.无法访问或更新响应式数据</h3><p>​	确保数据在<code>data</code>选项中声明为响应式，并使用正确的方式访问和更新数据，例如使用<code>this.xxx</code>来访问和更新组件内的数据。</p>
<h3 id="3-事件监听器无效"><a href="#3-事件监听器无效" class="headerlink" title="3.事件监听器无效"></a>3.事件监听器无效</h3><p>确保事件监听器绑定正确，检查事件名称和方法名是否拼写正确，确保方法在组件中存在。</p>
<h3 id="4-Vuex状态无法正常使用"><a href="#4-Vuex状态无法正常使用" class="headerlink" title="4.Vuex状态无法正常使用"></a>4.Vuex状态无法正常使用</h3><p>确保正确配置和使用Vuex，包括在Vue应用中正确安装Vuex插件、定义并导出Vuex模块、在组件中使用<code>mapState</code>、<code>mapGetters</code>、<code>mapActions</code>等辅助函数等。</p>
<h3 id="5-路由导航问题"><a href="#5-路由导航问题" class="headerlink" title="5.路由导航问题"></a>5.路由导航问题</h3><p>在使用Vue Router时，可能会遇到路由导航相关的问题，如路由重定向、路由守卫等。确保正确配置和使用路由，包括定义路由规则、使用<code>&lt;router-link&gt;</code>进行导航、使用路由守卫进行权限控制等。</p>
<h3 id="6-性能问题"><a href="#6-性能问题" class="headerlink" title="6.性能问题"></a>6.性能问题</h3><p>如果应用出现性能问题，可以使用浏览器的开发者工具进行性能分析，找出性能瓶颈并进行优化。一些常见的性能优化技巧包括使用虚拟列表进行大量数据的渲染、合理使用懒加载和异步组件、避免不必要的计算和渲染等。</p>
<h3 id="7-组件通信问题"><a href="#7-组件通信问题" class="headerlink" title="7.组件通信问题"></a>7.组件通信问题</h3><p>在组件之间进行通信时，可以使用Props和事件来实现父子组件之间的通信，使用Vuex实现跨组件的状态管理，使用Provide&#x2F;Inject实现祖先和后代组件之间的通信。</p>
<h3 id="8-异步操作和副作用问题"><a href="#8-异步操作和副作用问题" class="headerlink" title="8.异步操作和副作用问题"></a>8.异步操作和副作用问题</h3><p>在组件中进行异步操作或副作用时，可以使用<code>async/await</code>、Promise等方式处理异步逻辑，并在适当的生命周期钩子函数中执行副作用操作。</p>
<h3 id="9-调试和错误处理"><a href="#9-调试和错误处理" class="headerlink" title="9.调试和错误处理"></a>9.调试和错误处理</h3><p>使用浏览器的开发者工具进行调试，查看控制台输出的错误信息，以及Vue Devtools进行Vue应用的调试和监测。</p>
<p>如果遇到其他问题，可以参考Vue的官方文档、Vue社区论坛或向其他开发者寻求帮助。</p>
<h2 id="最后的项目实践和总结"><a href="#最后的项目实践和总结" class="headerlink" title="最后的项目实践和总结"></a>最后的项目实践和总结</h2><h3 id="1-项目实践"><a href="#1-项目实践" class="headerlink" title="1.项目实践"></a>1.项目实践</h3><p>项目实践是巩固和应用所学知识的重要环节。在Vue 3中，你可以尝试以下项目实践来进一步提升你的技能：</p>
<h4 id="1-建立一个任务管理应用"><a href="#1-建立一个任务管理应用" class="headerlink" title="1.建立一个任务管理应用"></a>1.建立一个任务管理应用</h4><p>创建一个简单的任务管理应用，包括添加、编辑和删除任务的功能。使用Vue Router实现路由导航，使用Vuex管理任务状态，以及使用组合式API构建可复用的组件。</p>
<h4 id="2-构建一个电子商务平台"><a href="#2-构建一个电子商务平台" class="headerlink" title="2.构建一个电子商务平台"></a>2.构建一个电子商务平台</h4><p>创建一个基于Vue 3的电子商务平台，包括商品列表、购物车、结算等功能。使用Vue Router管理不同页面之间的导航，使用Vuex管理购物车状态，以及使用组合式API构建商品列表和购物车组件。</p>
<h4 id="3-开发一个社交媒体应用"><a href="#3-开发一个社交媒体应用" class="headerlink" title="3.开发一个社交媒体应用"></a>3.开发一个社交媒体应用</h4><p>构建一个社交媒体应用，包括用户注册、登录、发布帖子、评论等功能。使用Vue Router实现不同页面的导航，使用Vuex管理用户信息和帖子数据，以及使用组合式API构建用户认证和帖子列表组件。</p>
<p>在项目实践过程中，你将面临各种挑战和问题，例如组件的设计和交互、数据管理和状态同步、性能优化等。通过解决这些问题，你将更深入地理解Vue 3的各个方面，并提升你的开发技能和项目经验。</p>
<h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h3><p>Vue 3是一个功能强大且灵活的JavaScript框架，具有直观的API和丰富的生态系统。通过学习Vue 3的核心概念、组件化开发、响应式数据、组合式API、路由管理和状态管理等内容，你可以构建出高质量、可维护和可扩展的Web应用程序。</p>
<p>在项目实践中，不仅要关注技术层面的实现，还要注重良好的代码结构、模块化和可测试性。同时，了解Vue 3的性能优化技巧和最佳实践，可以提高应用程序的加载速度和响应性能。</p>
<p>最重要的是保持持续学习和实践的态度，参与开发社区和与其他开发者交流经验，从实践中不断提升自己的Vue 3技能，并将其应用于真实的项目中。祝你在Vue 3的学习和项目实践中取得成功！</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>英语翻译练习</title>
    <url>/posts/1429.html</url>
    <content><![CDATA[<p>英语翻译练习，加强阅读能力，每日必备！！</p>
<span id="more"></span>

<h1 id="现象分析文"><a href="#现象分析文" class="headerlink" title="现象分析文"></a>现象分析文</h1><p>就现象分析原因，往往带有作者主观色彩</p>
<h2 id="Passage-1"><a href="#Passage-1" class="headerlink" title="Passage 1"></a>Passage 1</h2><p><strong>2001.Text.3</strong></p>
<h3 id="Paragraph1"><a href="#Paragraph1" class="headerlink" title="Paragraph1"></a>Paragraph1</h3><p>① Why do so many Americans distrust what they read in their newspapers? </p>
<p>​	为什么很多美国人不相信他们在他们的报纸里读到的东西</p>
<p>② The American Society of Newspaper Editors is trying to answer this painful question. </p>
<p>​	美国报纸编辑协会正试图回答这个痛苦的问题</p>
<p>③ The organization is deep into a long self-analysis known as the journalism credibility project.</p>
<p>​	该组织正深入(deep into)长期的自我分析称为(known as)新闻可信度（credobility）项目</p>
<h3 id="Paragraph2"><a href="#Paragraph2" class="headerlink" title="Paragraph2"></a>Paragraph2</h3><p>① <strong>Sad to say</strong>, this project has turned out to be mostly low-level findings about factual errors and spelling and grammar mistakes, combined with lots of head scratching puzzlement about what in the world those readers really want.</p>
<p>​	遗憾的是，这次项目的结果证明（turned out）很大程度上是(is mostly)低级的发现关于事实错误和拼写与语法上的错误，还有一些令人头痛(head scratching)的问题关于这些读者真正想要的究竟（in the world）是什么。</p>
<p>② <strong>But</strong> the sources of distrust go way deeper. </p>
<p>​	但是这种不信任的源头走得更深（go way deeper）</p>
<p>③ Most journalists learn to see the world through a set of standard templates (patterns) <strong>into which</strong> they plug each day’s events.</p>
<p>​	大多数记者学着去看待这个世界通过一套的标准模板，模板被他们插入每天发生的事。</p>
<p>​	“<strong>into which</strong>“是连接两个句子或从句的关系代词,<strong>表示前面的句子中的某物进入或转换成后面的句子所述的状态或形式</strong>。</p>
<p>​	例如: This is a crisis into which we never dreamed we would enter.</p>
<p>​	表示: “我们从未梦想我们会陷入这种危机之中”。</p>
<p>​	又如: His anger changed into a calmness into which I couldn’t penetrate.<br>​    表示: “他的愤怒转变成一种宁静,这种宁静我无法理解。”</p>
<p>​	本句话还可以翻译为：大多数记者学会通过一套标准模板(模式)来观察世界，他们把每天发生的事情都塞进去（这种模式）。</p>
<p>④ In other words, there is a conventional story line in the newsroom culture that provides a backbone and a ready-made narrative structure for otherwise confusing news.</p>
<p>​	换言之，在新闻采编室文化中有一个传统的&#x2F;约定成俗的（conventional）写作模式（story line），为原本（otherwise）复杂的新闻提供一个主干框架和一个现成的叙述(narrative)结构。</p>
<h3 id="Paragraph3"><a href="#Paragraph3" class="headerlink" title="Paragraph3"></a>Paragraph3</h3><p>① There exists a social and cultural disconnect between journalists and their readers, which helps explain why the “standard templates” of the newsroom seem alien to many readers. </p>
<p>​	在作者和读者之间存在一个社会和文化的断联，这有助于解释为什么对大多数读者而言新闻采编室的标准模板看起来是陌生的（alien）</p>
<p>② In a recent survey, questionnaires were sent to reporters in five middle-size cities around the country, plus one large metropolitan area.</p>
<p>​	在最近的调查里，问卷被送到了全国5座中等都市，加上（及）一座大都市(metropolitan)的记者手中。</p>
<p>③ Then residents in these communities were phoned at random and asked the same questions.</p>
<p>​	然后这些城市的居民被随机打电话并且被问相同的问题。</p>
<h3 id="Paragraph4"><a href="#Paragraph4" class="headerlink" title="Paragraph4"></a>Paragraph4</h3><p>① Replies show that compared with other Americans, journalists are more likely to live in upscale neighborhoods, have maids, own Mercedeses, and trade stocks, and they’re less likely to go to church, do volunteer work, or put down roots in a community.</p>
<p>​	结果表明：相比与其他美国人，新闻记者更可能住在大规模社区，有女仆，有奔驰，有股票，并且他们很少可能去教堂，做志愿者工作，或者扎根社区。</p>
<h3 id="Paragraph5"><a href="#Paragraph5" class="headerlink" title="Paragraph5"></a>Paragraph5</h3><p>① Reporters <strong>tend to</strong> be part of a broadly defined social and cultural elite, so their work tends to reflect the conventional values of this elite. </p>
<p> 记者往往（tend to）被广泛地定义为是社会文化精英的一个部分，因此他们的工作往往反映了这些精英传统的价值观</p>
<p>② The astonishing distrust of the news media isn’t <strong>rooted</strong> in inaccuracy or poor reportorial skills <strong>but</strong> in the daily clash of world views between reporters and their readers.</p>
<p>​	新闻媒体造成的令人惊讶的不信任根本（root）不是（并非）不准确或者贫瘠的报道技巧而是在日常中作者和他们读者间不同世界观的碰撞。</p>
<h3 id="Paragraph6"><a href="#Paragraph6" class="headerlink" title="Paragraph6"></a>Paragraph6</h3><p>① This is an explosive situation for any industry, particularly a declining one.</p>
<p>​	这是一个爆炸性(explosive)的情况对任何一个行业，尤其是走下坡路的行业。</p>
<p>② Here is a troubled business that keeps hiring employees whose attitudes vastly annoy the customers. </p>
<p>​	这是一个困难的行业：雇佣者雇佣员工的态度非常惹怒顾客</p>
<p>③ Then it sponsors lots of symposiums and a credibility project dedicated to wondering why customers are annoyed and fleeing in large numbers. </p>
<p>​	因此美国报纸编辑协会赞助了许多研讨会和可信度调查项目专注于搞明白为什么顾客们烦恼并且逃避新闻。</p>
<p>④ But it never seems to <strong>get around to</strong> noticing the cultural and class biases that so many former buyers are complaining about. </p>
<p>​	但是它似乎从来没有抽空(get aroud to)注意到哪些许多先前的购买者抱怨的文化和阶级偏见。</p>
<p>⑤ If it did, it would <strong>open up</strong> its diversity program, now focused narrowly on race and gender, and look for reporters who differ broadly by outlook, values, education, and class.</p>
<p>​	如果它注意到了，它就应该展开（open up）它的多样化项目（目前狭隘地专注于种族和性别）并且寻找在态度，价值观，教育和阶级有很大不同的记者。</p>
<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><ol>
<li>The results of the journalism credibility project turned out ____.</li>
</ol>
<p>​		新闻可信度项目的结果是，</p>
<p>​		A. Quite trustworthy.（相当值得信赖）</p>
<p>​		B. Somewhat contradictory.（有些矛盾）</p>
<p>​		C. Very illustrating.（非常清晰的）</p>
<p>​		D. Rather superficial.（非常肤浅）</p>
<ol start="2">
<li>The basic problem of journalists as pointed out by the writer lies in their ____.</li>
</ol>
<p>​		作者指出新闻记者的根本问题在于他们的</p>
<p>​		A. Working attitude.（工作态度）</p>
<p>​		B. Conventional lifestyle.（传统的生活方式）</p>
<p>​		C. World outlook.（时间观）</p>
<p>​		D. Educational background.（教育背景）</p>
<ol start="3">
<li>Despite its efforts, the newspaper industry still cannot satisfy the readers owing to its ____.</li>
</ol>
<p>​		尽管它付出了努力，报纸行业依然不能满足注册归因于它的</p>
<p>​		A. Failure to realize its real problem.（没能意识到真正的问题）</p>
<p>​		B. Tendency to hire annoying reporters.（倾向雇佣令人恼怒的记者）</p>
<p>​		C. Likeliness to do inaccurate reporting.（做不准确的报告的可能性）</p>
<p>​		D. Prejudice in matters of race and gender.（种族和性别问题上的偏见）</p>
<ol start="4">
<li>What is the passage mainly about?</li>
</ol>
<p>​		A. Needs of the readers all over the world.（全世界读者的需求）</p>
<p>​		B. Causes of the public disappointment about newspaper.（大众不满意新闻报纸的原因）</p>
<p>​		C. Origins of the declining newspaper industry.（报纸行业衰退的起因）</p>
<p>​		D. Aims of a journalism credibility project.（新闻可信度项目的目的）</p>
<p>答案：D，C，A，B</p>
<h2 id="Passage2"><a href="#Passage2" class="headerlink" title="Passage2"></a>Passage2</h2><p><strong>1997.Text.2</strong></p>
<h3 id="Paragraph1-1"><a href="#Paragraph1-1" class="headerlink" title="Paragraph1"></a>Paragraph1</h3><p>① A report consistently brought back by visitors to the US is how friendly, courteous, and helpful most Americans were to them. </p>
<p>​	一个报告经常（consistently）被去美国的旅客带回：美国人对于他们是如此友好的，好客的（courteous），助人的。</p>
<p>② To be fair, this observation is also frequently made of Canada and Canadians, and should best be considered North American. </p>
<p>​	实在地说，加拿大和加拿大人也频繁地有这样的评论（observation），最好应该认为是北美的地区的人。</p>
<p>③ There are, of course, exceptions. </p>
<p>​	这当然也有例外</p>
<p>④ Small-minded officials, rude waiters, and ill-mannered taxi drivers are hardly unknown in the US. </p>
<p>​	在美国小肚鸡肠的官员，粗鲁的服务员和不礼貌的出租车司机并不少见</p>
<p>⑤ <strong>Yet</strong> it is an observation made so frequently that it deserves comment.</p>
<p>​	然而，被如此频繁评论，它是值得加以讨论的</p>
<h3 id="Paragraph2-1"><a href="#Paragraph2-1" class="headerlink" title="Paragraph2"></a>Paragraph2</h3><p>① For a long period of time and in many parts of the country, a traveler was a welcome break in an otherwise dull existence. </p>
<p>​	在很长的时期和大部分国家，在一个原本枯燥乏味的生活（existence&#x3D;life）中旅客们是受欢迎的消遣。</p>
<p>② Dullness and loneliness were common problems of the families who generally lived distant from one another.</p>
<p>​	枯燥和孤独是那些通常彼此相距遥远（distant from one another）家庭的共同问题</p>
<p>③ Strangers and travelers were welcome sources of diversion, and brought news of the outside world.</p>
<p>​	陌生人和旅客们是被欢迎的消遣根源，并且带来一些外界新的事物。</p>
<h3 id="Paragraph3-1"><a href="#Paragraph3-1" class="headerlink" title="Paragraph3"></a>Paragraph3</h3><p>① The harsh realities of the frontier also shaped this tradition of hospitality. </p>
<p>​	边境的艰难现实也形成了这传统的友好。</p>
<p>② Someone traveling alone, if hungry, injured, or ill, often had nowhere to turn except to the nearest cabin or settlement.</p>
<p>​	 一些独自旅行的人，如果饥饿，受伤或者生病，经常除了去附近的木屋或定居点就没有地方去。</p>
<p>③ It was not a matter of choice for the traveler or merely a charitable impulse on the part of the settlers. </p>
<p>​	这对旅行者不是一个选择的问题，且对部分居住的人不仅仅是慈善的冲动（impulse）</p>
<p>④ It reflected the harshness of daily life: if you didn’t take in the stranger and take care of him, there was no one else who would.</p>
<p>​	它反应了日常生活的艰辛：如果你不接纳陌生人并且照顾他，就没有其他人会这样做。</p>
<p>⑤ And someday, remember, you might be in the same situation.</p>
<p>​	并且记住某天你也可能处于相同的情况。</p>
<h3 id="Paragraph4-1"><a href="#Paragraph4-1" class="headerlink" title="Paragraph4"></a>Paragraph4</h3><p>① Today there are many charitable organizations which specialize in helping the weary traveler. </p>
<p>​	今天有许多慈善的组织专门在帮助疲惫虚弱的旅客</p>
<p>② <strong>Yet</strong>, the old tradition of hospitality to strangers is still very strong in the US, especially in the smaller cities and towns away from the busy tourist trails. </p>
<p>​	然而，在美国对陌生人友善的老传统仍然非常强烈，特别是在远离繁华的旅游路线的小城市和小城镇</p>
<p>③ “I was just traveling through, got talking with this American, and pretty soon he invited me home for dinner – amazing.”</p>
<p>​	“惊人！我只是旅行经，和美国人聊了聊，他很快就邀请我去他家共进晚餐.”</p>
<p>④ Such observations reported by visitors to the US are not uncommon, but are not always understood properly. </p>
<p>​	这样的评论被去美国的游客反馈并不罕见但并不总是被正确的理解</p>
<p>⑤ The casual friendliness of many Americans should be interpreted neither as superficial nor as artificial, <strong>but</strong> as the <strong>result</strong> of a historically developed cultural tradition.</p>
<p>​	许多美国人随意的友好应该被解释既不肤浅也不矫揉造作的，而是由于一个历史发展的文化传统的结果</p>
<h3 id="Parapraph5"><a href="#Parapraph5" class="headerlink" title="Parapraph5"></a>Parapraph5</h3><p>① <strong>As is true of</strong> any developed society, in America a complex set of cultural signals, assumptions, and conventions underlies all social interrelationships. </p>
<p>​	就像（as is true of）任何发展社会，在美国，一套复杂的文化标志，假说和习俗构成所有社会关系的基础（underlies构成…的基础）</p>
<p>② And, of course, speaking a language does not necessarily mean that someone understands social and cultural patterns. </p>
<pre><code> 当然，说一门语音并不一定意味要人理解社会和文化的模式
</code></pre>
<p>③ Visitors who fail to ‘translate’ cultural meanings properly often draw wrong conclusions. </p>
<p>​	游客没能正确地“翻译”文化的含义通常会得出错误的结论</p>
<p>④ For example, when an American uses the word ‘friend,’ the cultural implications of the word may be quite different from those it has in the visitor’s language and culture. </p>
<p>​	比如，当美国人使用单词“friend”，单词的文化含义（implication）也许与那些游客的语言和文化有许多不同。</p>
<p>⑤ It <strong>takes more than</strong> a brief encounter on a bus to distinguish between courteous convention and individual interest. </p>
<p>​	它不只是（take more than）一个简短的偶遇在公交车上能区分礼貌惯例和个人兴趣</p>
<p>⑥ <strong>Yet</strong>, being friendly is a virtue that many Americans value highly and expect from both neighbors and strangers.</p>
<p>​	然而，保持友好是一个美德，许多美国非常重视，并期望领居和陌生人能友好</p>
<h3 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h3><ol>
<li>In the eyes of visitors from the outside world, ____.</li>
</ol>
<p>​		在外界游客的眼中，</p>
<p>​		A. rude taxi drivers are rarely seen in the US.（粗鲁的司机很少出现在美国）</p>
<p>​		B. small-minded officials deserve a serious comment.（小肚鸡肠的官员应该得被严重批评）</p>
<p>​		C. Canadians are not so friendly as their neighbors（加拿大人对他们的邻居是不友好的）</p>
<p>​		D. most Americans are ready to offer help.（大多数美国人都愿意（ready）提供帮助）</p>
<ol start="2">
<li>It could be inferred from the last paragraph that ____.</li>
</ol>
<p>​		A. Culture exercises an influence over social interrelationship.（文化对社会相互的关系有影响exercise an influence over）</p>
<p>​		B. Courteous convention and individual interest are interrelated.（礼貌的惯例和个人的兴趣是相互关联的）</p>
<p>​		C. Various virtues manifest themselves exclusively among friends.（各种美德（virtues）仅仅（exclusively）在朋友之间among显现出来）</p>
<p>​		D. Social interrelationships equal the complex set of cultural conventions.（社会关系等于复杂的文化习俗的集合）</p>
<ol start="3">
<li>Families in frontier settlements used to entertain strangers ____.</li>
</ol>
<p>​		边境定居点的家庭过去常常招待陌生人</p>
<p>​		A. to improve their hard life.（提高他们的艰难的生活）</p>
<p>​		B. in view of their long-distance travel.（鉴于（in view）他们远距离的旅行）</p>
<p>​		C. to add some flavor to their own daily life.（为他们日常生活添加一些情趣）</p>
<p>​		D. out of a charitable impulse.（出于慈善的冲动）</p>
<ol start="4">
<li>The tradition of hospitality to strangers ____.</li>
</ol>
<p>​		对陌生人友好的传统</p>
<p>​		A. tends to be superficial and artificial（往往是肤浅的和矫揉造作的）</p>
<p>​		B. is generally well kept up in the United States（在美国普遍保持得很好）</p>
<p>​		C. is always understood properly（总是被正确地理解）</p>
<p>​		D. <strong>has something to do with</strong> the busy tourist trails.（和（繁忙的旅游路线）有关）</p>
<p>答案：D，A，C，B</p>
<h2 id="Passage-12"><a href="#Passage-12" class="headerlink" title="Passage 12"></a>Passage 12</h2><p><strong>2000.Text.4</strong></p>
<h3 id="Paragraph1-2"><a href="#Paragraph1-2" class="headerlink" title="Paragraph1"></a>Paragraph1</h3><p>① Aimlessness has hardly been typical of the postwar Japan whose productivity and social harmony are the envy of the United States and Europe. </p>
<p>​	无目的性几乎不是战后日本的典型特征，其生产力和社会和谐令美国和欧洲羡慕不已</p>
<p>② But increasingly the Japanese are seeing a decline of the traditional work-moral values. </p>
<p>​	但是，越来越多的日本人看到了传统职业道德价值的衰落</p>
<p>③ Ten years ago young people were hardworking and saw their jobs as their primary reason for being, but now Japan has largely fulfilled its economic needs, and young people don’t know where they should go next.</p>
<p>​	十年前，年轻人勤奋工作，将工作视为自己存在的主要原因，但如今日本已经基本满足了经济需求，年轻人不知道接下来该去哪里</p>
<h3 id="Paragraph2-2"><a href="#Paragraph2-2" class="headerlink" title="Paragraph2"></a>Paragraph2</h3><p>① The coming of age of the postwar baby boom and an entry of women into the male-dominated job market have limited the opportunities of teenagers who are already questioning the heavy personal sacrifices involved in climbing Japan’s rigid social ladder to good schools and jobs. </p>
<p>​	战后婴儿潮的成年和女性进入男性主导的就业市场，限制了对已经对攀登日本严格社会阶梯上好学校和工作所付出巨大个人牺牲的青少年的机会</p>
<p>② In a recent survey, it was found that only 24.5 percent of Japanese students were fully satisfied with school life, compared with 67.2 percent of students in the United States. </p>
<p>​	最近的一项调查发现，只有24.5％的日本学生对学校生活完全满意，而美国学生中有67.2％对此感到满意</p>
<p>③ In addition, far more Japanese workers expressed dissatisfaction with their jobs than did their counterparts in the 10 other countries surveyed.</p>
<p>​	此外，在另外10个受调查国家中，更多的日本工人表示对工作不满意</p>
<h3 id="Paragraph3-2"><a href="#Paragraph3-2" class="headerlink" title="Paragraph3"></a>Paragraph3</h3><p>① While often praised by foreigners for its emphasis on the basics, Japanese education tends to stress test taking and mechanical learning over creativity and self expression. </p>
<p>​	外国人经常称赞日本教育注重基础知识，但往往强调应试和机械式学习，而不是创造力和自我表达</p>
<p>② “Those things that do not show up in the test scores— personality, ability, courage or humanity—are completely ignored,” says ToShiki Kaifu, chairman of the ruling Liberal Democratic Party’s education committee.</p>
<p>​	执政党自由民主党的教育委员会主席葛藤敏树表示：“那些不在考试成绩中显示的事情——个性、能力、勇气或人性——完全被忽视。”</p>
<p>③ “Frustration against this kind of thing leads kids to drop out and run Wild.”</p>
<p>​	“对这种事情的沮丧导致孩子们辍学并放任自流。”</p>
<p>④ Last year Japan experienced 2,125 incidents of school violence, including 929 assaults on teachers. </p>
<p>​	去年日本发生了2,125起校园暴力事件，其中包括对教师的929起袭击。</p>
<p>⑤ Amid the outcry, many conservative leaders are seeking a return to the prewar emphasis on moral education. </p>
<p>​	在强烈抗议声中，许多保守派领导人寻求回归到战前对道德教育的强调。</p>
<p>⑥ Last year Mitsuo Setoyama, who was then education minister, raised eyebrows when he argued that liberal reforms introduced by the American occupation authorities after World War II had weakened the “Japanese morality of respect for parents.”</p>
<p>​	去年时任教育部长的瀬戸山光夫在提出，美国占领当局在二战后引入的自由改革削弱了“对父母的尊重的日本道德观”</p>
<h3 id="Paragraph4-2"><a href="#Paragraph4-2" class="headerlink" title="Paragraph4"></a>Paragraph4</h3><p>① But that may have more to do with Japanese life-styles. </p>
<p>​	 但这可能更多地与日本的生活方式有关</p>
<p>② “ln Japan,” says educator Yoko Muro,”it’s never a question of whether you enjoy your job and your life, but only how much you can endure.”</p>
<p>​	教育家室阳子表示：“在日本，从不是你是否享受工作和生活的问题，而只是你能忍受多少。”</p>
<p>③ With economic growth has come centralization; fully 76 percent of Japan’s 119 million citizens live in cities where community and the extended family have been abandoned in favor of isolated, two -generation households.</p>
<p>​	随着经济的增长，集中化成为现实。日本1.19亿人口中，有76%居住在城市，社区和大家庭已被抛弃，代之以孤立的两代人家庭</p>
<p>④ Urban Japanese have long endured lengthy commutes (travels to and from work) and crowded living conditions, but as the old group and family values weaken, the discomfort is beginning to tell. </p>
<p>​	城市中的日本人长期以来忍受着长途通勤和拥挤的居住条件，但随着旧有的集体和家庭价值观的减弱，这种不适感开始显现出来。</p>
<p>⑤ In the past decade, the Japanese divorce rate, while still well below that of the United States, has increased by more than 50 percent, and suicides have increased by nearly one-quarter.</p>
<p>​	在过去的十年中，日本的离婚率虽然仍远低于美国，但增长了超过50%，自杀人数增加了近四分之一</p>
<h3 id="Question-2"><a href="#Question-2" class="headerlink" title="Question"></a>Question</h3><p>​	1.In the Westerners’ eyes, the postwar Japan was ___.</p>
<p>​		A. a positive example</p>
<p>​		B. under aimless development</p>
<p>​		C. on the decline</p>
<p>​		D. a rival to the West</p>
<ol start="2">
<li>According to the author, what may chiefly be responsible for the moral decline of Japanese society?</li>
</ol>
<p>​		A. More workers are dissatisfied with their jobs.</p>
<p>​		B. Women’s participation in social activities is Iimited</p>
<p>​		C. The life-style has been influenced by Western values.</p>
<p>​		D. Excessive emphasis has been placed on the basics.</p>
<ol start="3">
<li>Which of the following is true according to the author?</li>
</ol>
<p>​		A. Japanese education is praised for helping the young climb the social ladder.</p>
<p>​		B. Japanese education is characterized by mechanical learning as well as creativity.</p>
<p>​		C. Dropping out leads to frustration against test taking.</p>
<p>​		D. More stress should be placed on the cultivation of creativity.</p>
<ol start="4">
<li>The change in Japanese life-style is revealed in the fact that ___.</li>
</ol>
<p>​		A. the divorce rate in Japan exceeds that in the U.S.</p>
<p>​		B. the young are less tolerant of discomforts in life</p>
<p>​		C. the Japanese endure more than ever before</p>
<p>​		D. the Japanese appreciate their present life</p>
<h1 id="立论文"><a href="#立论文" class="headerlink" title="立论文"></a>立论文</h1><h2 id="Passage-4"><a href="#Passage-4" class="headerlink" title="Passage 4"></a>Passage 4</h2><p><strong>2000.Text.1</strong></p>
<h3 id="Paragraph1-3"><a href="#Paragraph1-3" class="headerlink" title="Paragraph1"></a>Paragraph1</h3><p>① A history of long and effortless success can be a dreadful handicap, but, if properly handled, it may become a driving force. </p>
<p>​	长期而轻松的成功历史可能成为一种可怕的障碍，但如果妥善处理，它可能成为一种推动力。</p>
<p>② When the United States entered just such a glowing period after the end of the Second World War, it had a market eight times larger than any competitor, giving its industries unparalleled economies of scale.</p>
<p>​	 当美国在二战结束后进入了这样一个光辉时期时，它的市场规模是任何竞争对手的八倍，使其工业拥有无与伦比的规模经济效益。</p>
<p>③ Its scientists were the world’s best, its workers the most skilled.</p>
<p>​	 它的科学家是世界上最好的，它的工人是最熟练的。</p>
<p>④ America and Americans were prosperous beyond the dreams of the Europeans and Asians whose economies the war had destroyed.</p>
<p>​	美国和美国人的繁荣超过了那些战争摧毁了他们经济的欧洲和亚洲人的梦想。</p>
<h3 id="Paragraph2-3"><a href="#Paragraph2-3" class="headerlink" title="Paragraph2"></a>Paragraph2</h3><p>① It was inevitable that this primacy should have narrowed as other countries grew richer. </p>
<p>​	这种优势的缩小是不可避免的</p>
<p> ② Just as inevitably, the retreat from predominance proved painful. </p>
<p>​	同样不可避免的是，优势地位的退却是痛苦的</p>
<p>③ By the mid-1980s Americans had found themselves at a loss over their fading industrial competitiveness. </p>
<p>​	到了20世纪80年代中期，美国人发现他们在日益减弱的工业竞争力面前感到迷茫</p>
<p>④ Some huge American industries, such as consumer electronics, had shrunk or vanished in the face of foreign competition. </p>
<p>​	 一些庞大的美国行业，如消费电子行业，在外国竞争面前已经缩小或消失</p>
<p>⑤ By 1987 there was only one American television maker left, Zenith. (Now there is none: Zenith was bought by South Korea’ s LG Electronics in July.)</p>
<p>​	到1987年，美国只剩下一家电视制造商——Zenith。（现在已经没有了：Zenith在2000年7月被韩国的LG电子收购。）</p>
<p>⑥ Foreign-made cars and textiles were sweeping into the domestic market. </p>
<p>​	外国制造的汽车和纺织品正在涌入国内市场</p>
<p>⑦ America’s machine-tool industry was on the ropes. </p>
<p>​	美国的机床行业陷入困境</p>
<p>⑧ For a while it looked as though the making of semiconductors, which America had invented and which sat at the heart of the new computer age, was going to be the next casualty.</p>
<p>​	一度看起来，美国发明并处于新的计算机时代核心的半导体制造业也将成为下一个受害者</p>
<h3 id="Paragraph3-3"><a href="#Paragraph3-3" class="headerlink" title="Paragraph3"></a>Paragraph3</h3><p>① All of this caused a crisis of confidence. </p>
<p>​	所有这些导致了信心危机</p>
<p>② Americans stopped taking prosperity for granted. </p>
<p>​	美国人不再把繁荣视为理所当然</p>
<p>③ They began to believe that their way of doing business was failing, and that their incomes would therefore shortly begin to fall as well. </p>
<p>​	 他们开始相信他们的商业方式正在失败，因此他们的收入也将很快开始下降。</p>
<p>④ The mid-1980s brought one inquiry after another into the causes of America’s industrial decline. </p>
<p>​	20世纪80年代中期，对美国工业衰落原因的调查接踵而至</p>
<p>⑤ Their sometimes sensational findings were filled with warnings about the growing competition from overseas.</p>
<p>​	他们有时会带来轰动性的发现，充满了对来自海外竞争的警告</p>
<h3 id="Paragraph4-3"><a href="#Paragraph4-3" class="headerlink" title="Paragraph4"></a>Paragraph4</h3><p>① How things have changed! </p>
<p>​	情况变化了！</p>
<p>② In 1995 the United States can look back on five years of solid growth while Japan has been struggling. </p>
<p>​	在1995年，美国回顾过去五年的坚实增长，而日本一直在苦苦挣扎</p>
<p>③ Few Americans attribute this solely to such obvious causes as a devalued dollar or the turning of the business cycle. </p>
<p>​	很少有美国人把这完全归因于明显的原因，如货币贬值或商业周期的转折</p>
<p>④ Self-doubt has yielded to blind pride. </p>
<p>​	自我怀疑已经让位于盲目的自豪</p>
<p>⑤ “American industry has changed its structure, has gone on a diet, has learnt to be more quick-witted,” according to Richard Cavanagh, executive dean of Harvard’s Kennedy School of Government.</p>
<p>​	“美国工业已经改变了结构，进行了减肥，学会了更加机智应对，” 哈佛大学肯尼迪政府学院的执行院长理查德·卡瓦纳说道。</p>
<p>⑥ “It makes me proud to be an American just to see how our businesses are improving their productivity,” says Stephen Moore of the Cato Institute, a think-tank in Washington, DC. </p>
<p>​	华盛顿特区智库卡托研究所的斯蒂芬·摩尔表示：“看到我们的企业如何提高生产率，我为自己是美国人感到自豪。”</p>
<p>⑦ And William Sahlman of the Harvard Business School believes that people will look back on this period as “a golden age of business management in the United States.”</p>
<p>​	哈佛商学院的威廉·萨尔曼认为，人们将会回顾这个时期，视其为“美国商业管理的黄金时代”</p>
<h3 id="Question-3"><a href="#Question-3" class="headerlink" title="Question"></a>Question</h3><ol>
<li>The US achieved its predominance after World War II because ____.</li>
</ol>
<p>​		A. It had made painstaking efforts towards this goal</p>
<p>​		B. Its domestic market was eight times larger than before</p>
<p>​		C. The war had destroyed the economies of most potential competitors</p>
<p>​		D. The unparalleled size of its workforce had given an impetus to its economy</p>
<ol start="2">
<li>The loss of US predominance in the world economy in the 1980s is manifested in the fact that the American _____.</li>
</ol>
<p>​		A. TV industry had withdrawn to its domestic market.</p>
<p>​		B. Semiconductor industry had been taken over by foreign enterprises.</p>
<p>​		C. Machine-tool industry had collapsed after suicidal actions.</p>
<p>​		D. Auto industry had lost part of its domestic market.</p>
<ol start="3">
<li>What can be inferred from the passage?</li>
</ol>
<p>​		A. It is human nature to shift between self-doubt and blind pride.</p>
<p>​		B. Intense competition may contribute to economic progress.</p>
<p>​		C. The revival of the economy depends on international cooperation.</p>
<p>​		D. A long history of success may pave the way for further development.</p>
<ol start="4">
<li>The author seems to believe that the revival of the US economy in the 1990s can be attributed to the _____.</li>
</ol>
<p>​		A. Turning of the business cycle</p>
<p>​		B. Restructuring of industry</p>
<p>​		C. Improved business management</p>
<p>​		D. Success in education</p>
]]></content>
      <categories>
        <category>考研英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言</title>
    <url>/posts/c6f.html</url>
    <content><![CDATA[<h1 id="C-简介"><a href="#C-简介" class="headerlink" title="C 简介"></a>C 简介</h1><p>C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。</p>
<p>在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&amp;R 标准。</p>
<p>UNIX 操作系统，C编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。</p>
<ul>
<li>易于学习。</li>
<li>结构化语言。</li>
<li>它产生高效率的程序。</li>
<li>它可以处理底层的活动。</li>
<li>它可以在多种计算机平台上编译。</li>
</ul>
<span id="more"></span>
<h2 id="关于-C"><a href="#关于-C" class="headerlink" title="关于 C"></a>关于 C</h2><ul>
<li>C 语言是为了编写 UNIX 操作系统而被发明的。</li>
<li>C 语言是以 B 语言为基础的，B 语言大概是在 1970 年被引进的。</li>
<li>C 语言标准是于 1988 年由美国国家标准协会（ANSI，全称 American National Standard Institute）制定的。</li>
<li>截至 1973 年，UNIX 操作系统完全使用 C 语言编写。</li>
<li>目前，C 语言是最广泛使用的系统程序设计语言。</li>
<li>大多数先进的软件都是使用 C 语言实现的。</li>
<li>当今最流行的 Linux 操作系统和 RDBMS（Relational Database Management System：关系数据库管理系统） MySQL 都是使用 C 语言编写的。</li>
</ul>
<h2 id="为什么要使用-C？"><a href="#为什么要使用-C？" class="headerlink" title="为什么要使用 C？"></a>为什么要使用 C？</h2><p>C 语言最初是用于系统开发工作，特别是组成操作系统的程序。由于 C 语言所产生的代码运行速度与汇编语言编写的代码运行速度几乎一样，所以采用 C 语言作为系统开发语言。下面列举几个使用 C 的实例：</p>
<ul>
<li>操作系统</li>
<li>语言编译器</li>
<li>汇编器</li>
<li>文本编辑器</li>
<li>打印机</li>
<li>网络驱动器</li>
<li>现代程序</li>
<li>数据库</li>
<li>语言解释器</li>
<li>实体工具</li>
</ul>
<h2 id="C-程序"><a href="#C-程序" class="headerlink" title="C 程序"></a>C 程序</h2><p>一个 C 语言程序，可以是 3 行，也可以是数百万行，它可以写在一个或多个扩展名为 <strong>“.c”</strong> 的文本文件中，例如，<em>hello.c</em>。您可以使用 <strong>“vi”<strong>、</strong>“vim”</strong> 或任何其他文本编辑器来编写您的 C 语言程序。</p>
<p>本教程假定您已经知道如何编辑一个文本文件，以及如何在程序文件中编写源代码。</p>
<h2 id="C11"><a href="#C11" class="headerlink" title="C11"></a>C11</h2><p>C11（也被称为C1X）指ISO标准ISO&#x2F;IEC 9899:2011。在它之前的C语言标准为C99。</p>
<h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><ul>
<li>对齐处理（Alignment）的标准化（包括_Alignas标志符，alignof运算符，aligned_alloc函数以及&lt;stdalign.h&gt;头文件）。</li>
<li>_Noreturn 函数标记，类似于 gcc 的 <strong>attribute</strong>((noreturn))。</li>
<li>_Generic 关键字。</li>
<li>多线程（Multithreading）支持，包括：<br>_Thread_local存储类型标识符，&lt;threads.h&gt;头文件，里面包含了线程的创建和管理函数。<br>_Atomic类型修饰符和&lt;stdatomic.h&gt;头文件。</li>
<li>增强的Unicode的支持。基于C Unicode技术报告ISO&#x2F;IEC TR 19769:2004，增强了对Unicode的支持。包括为UTF-16&#x2F;UTF-32编码增加了char16_t和char32_t数据类型，提供了包含unicode字符串转换函数的头文件&lt;uchar.h&gt;。</li>
<li>删除了 gets() 函数，使用一个新的更安全的函数gets_s()替代。</li>
<li>增加了边界检查函数接口，定义了新的安全的函数，例如 fopen_s()，strcat_s() 等等。</li>
<li>增加了更多浮点处理宏(宏)。</li>
<li>匿名结构体&#x2F;联合体支持。这个在gcc早已存在，C11将其引入标准。</li>
<li>静态断言（Static assertions），_Static_assert()，在解释 #if 和 #error 之后被处理。</li>
<li>新的 fopen() 模式，(“…x”)。类似 POSIX 中的 O_CREAT|O_EXCL，在文件锁中比较常用。</li>
<li>新增 quick_exit() 函数作为第三种终止程序的方式。当 exit()失败时可以做最少的清理工作。</li>
</ul>
<h1 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C 程序结构"></a>C 程序结构</h1><p>在我们学习 C 语言的基本构建块之前，让我们先来看看一个最小的 C 程序结构，在接下来的章节中可以以此作为参考。</p>
<h2 id="C-Hello-World-实例"><a href="#C-Hello-World-实例" class="headerlink" title="C Hello World 实例"></a>C Hello World 实例</h2><p>C 程序主要包括以下部分：</p>
<ul>
<li>预处理器指令</li>
<li>函数</li>
<li>变量</li>
<li>语句 &amp; 表达式</li>
<li>注释</li>
</ul>
<p>让我们看一段简单的代码，可以输出单词 “Hello World”：</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="comment">/* 我的第一个 C 程序 */</span> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World! \n&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们讲解一下上面这段程序：</p>
<ol>
<li>程序的第一行 <em>#include &lt;stdio.h&gt;</em> 是预处理器指令，告诉 C 编译器在实际编译之前要包含 stdio.h 文件。</li>
<li>下一行 <em>int main()</em> 是主函数，程序从这里开始执行。</li>
<li>下一行 &#x2F;<em>…</em>&#x2F; 将会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释。</li>
<li>下一行 <em>printf(…)</em> 是 C 中另一个可用的函数，会在屏幕上显示消息 “Hello, World!”。</li>
<li>下一行 <strong>return 0;</strong> 终止 main() 函数，并返回值 0。</li>
</ol>
<h2 id="编译-amp-执行-C-程序"><a href="#编译-amp-执行-C-程序" class="headerlink" title="编译 &amp; 执行 C 程序"></a>编译 &amp; 执行 C 程序</h2><p>接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：</p>
<ol>
<li>打开一个文本编辑器，添加上述代码。</li>
<li>保存文件为 <em>hello.c</em>。</li>
<li>打开命令提示符，进入到保存文件所在的目录。</li>
<li>键入 <em>gcc hello.c</em>，输入回车，编译代码。</li>
<li>如果代码中没有错误，命令提示符会跳到下一行，并生成 <em>a.out</em> 可执行文件。</li>
<li>现在，键入 <em>a.out</em> 来执行程序。</li>
<li>您可以看到屏幕上显示 *”Hello World”*。</li>
</ol>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>gcc hello.c</span><br><span class="line"><span class="variable">$ </span>./a.<span class="keyword">out</span></span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<p>请确保您的路径中已包含 gcc 编译器，并确保在包含源文件 hello.c 的目录中运行它。</p>
<p>如果是多个 c 代码的源码文件，编译方法如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ gcc test1<span class="selector-class">.c</span> test2<span class="selector-class">.c</span> -o <span class="selector-tag">main</span><span class="selector-class">.out</span></span><br><span class="line">$ ./<span class="selector-tag">main</span>.out</span><br></pre></td></tr></table></figure>

<p>test1.c 与 test2.c 是两个源代码文件。</p>
<h1 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C 基本语法"></a>C 基本语法</h1><p>我们已经看过 C 程序的基本结构，这将有助于我们理解 C 语言的其他基本的构建块。</p>
<h2 id="C-的令牌（Token）"><a href="#C-的令牌（Token）" class="headerlink" title="C 的令牌（Token）"></a>C 的令牌（Token）</h2><p>C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。例如，下面的 C 语句包括五个令牌：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">printf(<span class="string">&quot;Hello, World! \n&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>这五个令牌分别是：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">printf</span><br><span class="line">(</span><br><span class="line"><span class="string">&quot;Hello, World! \n&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="分号"><a href="#分号" class="headerlink" title="分号 ;"></a>分号 ;</h2><p>在 C 程序中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。</p>
<p>例如，下面是两个不同的语句：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">printf(<span class="string">&quot;Hello, World! \n&quot;</span>)<span class="comment">;</span></span><br><span class="line">return <span class="number">0</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>C 语言有两种注释方式：</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 单行注释</span><br></pre></td></tr></table></figure>

<p>以 <strong>&#x2F;&#x2F;</strong> 开始的单行注释，这种注释可以单独占一行。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 单行注释 */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>&#x2F;* *&#x2F;</strong> 这种格式的注释可以单行或多行。</p>
<p>您不能在注释内嵌套注释，注释也不能出现在字符串或字符值中。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p>
<p>C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是<strong>区分大小写</strong>的编程语言。因此，在 C 中，<em>Manpower</em> 和 <em>manpower</em> 是两个不同的标识符。下面列出几个有效的标识符：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">mohd       zara    abc   <span class="keyword">move_name </span> a_123</span><br><span class="line">myname50   _temp   <span class="keyword">j </span>    a<span class="symbol">23b</span>9      retVal</span><br></pre></td></tr></table></figure>

<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p>
<table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">auto</td>
<td align="left">声明自动变量</td>
</tr>
<tr>
<td align="left">break</td>
<td align="left">跳出当前循环</td>
</tr>
<tr>
<td align="left">case</td>
<td align="left">开关语句分支</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">声明字符型变量或函数返回值类型</td>
</tr>
<tr>
<td align="left">const</td>
<td align="left">定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变</td>
</tr>
<tr>
<td align="left">continue</td>
<td align="left">结束当前循环，开始下一轮循环</td>
</tr>
<tr>
<td align="left">default</td>
<td align="left">开关语句中的”其它”分支</td>
</tr>
<tr>
<td align="left">do</td>
<td align="left">循环语句的循环体</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">声明双精度浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td align="left">else</td>
<td align="left">条件语句否定分支（与 if 连用）</td>
</tr>
<tr>
<td align="left">enum</td>
<td align="left">声明枚举类型</td>
</tr>
<tr>
<td align="left">extern</td>
<td align="left">声明变量或函数是在其它文件或本文件的其他位置定义</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">声明浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td align="left">for</td>
<td align="left">一种循环语句</td>
</tr>
<tr>
<td align="left">goto</td>
<td align="left">无条件跳转语句</td>
</tr>
<tr>
<td align="left">if</td>
<td align="left">条件语句</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">声明整型变量或函数</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">声明长整型变量或函数返回值类型</td>
</tr>
<tr>
<td align="left">register</td>
<td align="left">声明寄存器变量</td>
</tr>
<tr>
<td align="left">return</td>
<td align="left">子程序返回语句（可以带参数，也可不带参数）</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">声明短整型变量或函数</td>
</tr>
<tr>
<td align="left">signed</td>
<td align="left">声明有符号类型变量或函数</td>
</tr>
<tr>
<td align="left">sizeof</td>
<td align="left">计算数据类型或变量长度（即所占字节数）</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">声明静态变量</td>
</tr>
<tr>
<td align="left">struct</td>
<td align="left">声明结构体类型</td>
</tr>
<tr>
<td align="left">switch</td>
<td align="left">用于开关语句</td>
</tr>
<tr>
<td align="left">typedef</td>
<td align="left">用以给数据类型取别名</td>
</tr>
<tr>
<td align="left">unsigned</td>
<td align="left">声明无符号类型变量或函数</td>
</tr>
<tr>
<td align="left">union</td>
<td align="left">声明共用体类型</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">声明函数无返回值或无参数，声明无类型指针</td>
</tr>
<tr>
<td align="left">volatile</td>
<td align="left">说明变量在程序执行中可被隐含地改变</td>
</tr>
<tr>
<td align="left">while</td>
<td align="left">循环语句的循环条件</td>
</tr>
</tbody></table>
<h3 id="C99-新增关键字"><a href="#C99-新增关键字" class="headerlink" title="C99 新增关键字"></a>C99 新增关键字</h3><table>
<thead>
<tr>
<th><code>_Bool</code></th>
<th><code>_Complex</code></th>
<th><code>_Imaginary</code></th>
<th><code>inline</code></th>
<th><code>restrict</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="C11-新增关键字"><a href="#C11-新增关键字" class="headerlink" title="C11 新增关键字"></a>C11 新增关键字</h3><table>
<thead>
<tr>
<th><code>_Alignas</code></th>
<th><code>_Alignof</code></th>
<th><code>_Atomic</code></th>
<th><code>_Generic</code></th>
<th><code>_Noreturn</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>_Static_assert</code></td>
<td><code>_Thread_local</code></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="C-中的空格"><a href="#C-中的空格" class="headerlink" title="C 中的空格"></a>C 中的空格</h2><p>只包含空格的行，被称为空白行，可能带有注释，C 编译器会完全忽略它。</p>
<p>在 C 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int age<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">fruit</span> = apples + oranges<span class="comment">;   // 获取水果的总数</span></span><br></pre></td></tr></table></figure>

<p>fruit 和 &#x3D;，或者 &#x3D; 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。</p>
<h1 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C 数据类型"></a>C 数据类型</h1><p>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p>
<p>C 中的类型可分为以下几种：</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th>类型与描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><strong>基本类型：</strong> 它们是算术类型，包括两种类型：整数类型和浮点类型。</td>
</tr>
<tr>
<td align="center">2</td>
<td><strong>枚举类型：</strong> 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</td>
</tr>
<tr>
<td align="center">3</td>
<td><strong>void 类型：</strong> 类型说明符 <em>void</em> 表明没有可用的值。</td>
</tr>
<tr>
<td align="center">4</td>
<td><strong>派生类型：</strong> 它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</td>
</tr>
</tbody></table>
<p>数组类型和结构类型统称为聚合类型。函数的类型指的是函数返回值的类型。在本章节接下来的部分我们将介绍基本类型，其他几种类型会在后边几个章节中进行讲解。</p>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>下表列出了关于标准整数类型的存储大小和值范围的细节：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">存储大小</th>
<th align="left">值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td align="left">1 字节</td>
<td align="left">-128 到 127 或 0 到 255</td>
</tr>
<tr>
<td align="left">unsigned char</td>
<td align="left">1 字节</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left">signed char</td>
<td align="left">1 字节</td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">2 或 4 字节</td>
<td align="left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td align="left">2 或 4 字节</td>
<td align="left">0 到 65,535 或 0 到 4,294,967,295</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">2 字节</td>
<td align="left">-32,768 到 32,767</td>
</tr>
<tr>
<td align="left">unsigned short</td>
<td align="left">2 字节</td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">4 字节</td>
<td align="left">-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td align="left">unsigned long</td>
<td align="left">4 字节</td>
<td align="left">0 到 4,294,967,295</td>
</tr>
</tbody></table>
<p>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。</p>
<p>以下列出了32位系统与64位系统的存储大小的差别（windows 相同）：<img data-src="https://www.runoob.com/wp-content/uploads/2014/09/32-64.jpg" alt="image"></p>
<p>为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 <strong>sizeof</strong> 运算符。表达式 <em>sizeof(type)</em> 得到对象或类型的存储字节大小。下面的实例演示了获取 int 类型的大小：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;int 存储大小 : %lu \n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>%lu</strong> 为 32 位无符号整数，详细说明查看 <a href="https://www.runoob.com/cprogramming/c-function-printf.html">C 库函数 - printf()</a>。</p>
<p>当您在 Linux 上编译并执行上面的程序时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> 存储大小 : <span class="number">4</span> </span><br></pre></td></tr></table></figure>

<h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">存储大小</th>
<th align="left">值范围</th>
<th align="left">精度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">float</td>
<td align="left">4 字节</td>
<td align="left">1.2E-38 到 3.4E+38</td>
<td align="left">6 位有效位</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">8 字节</td>
<td align="left">2.3E-308 到 1.7E+308</td>
<td align="left">15 位有效位</td>
</tr>
<tr>
<td align="left">long double</td>
<td align="left">16 字节</td>
<td align="left">3.4E-4932 到 1.1E+4932</td>
<td align="left">19 位有效位</td>
</tr>
</tbody></table>
<p>头文件 float.h 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。下面的实例将输出浮点类型占用的存储空间以及它的范围值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;float 存储最大字节数 : %lu \n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;float 最小值: %E\n&quot;</span>, FLT_MIN );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;float 最大值: %E\n&quot;</span>, FLT_MAX );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;精度值: %d\n&quot;</span>, FLT_DIG );</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>%E</strong> 为以指数形式输出单、双精度实数，详细说明查看 <a href="https://www.runoob.com/cprogramming/c-function-printf.html">C 库函数 - printf()</a>。</p>
<p>当您在 Linux 上编译并执行上面的程序时，它会产生下列结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> 存储最大字节数 : <span class="number">4</span> </span><br><span class="line"><span class="type">float</span> 最小值: <span class="number">1.175494E-38</span></span><br><span class="line"><span class="type">float</span> 最大值: <span class="number">3.402823E+38</span></span><br><span class="line">精度值: <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h2 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h2><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">类型与描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>函数返回为空</strong> C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 <strong>void exit (int status);</strong></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>函数参数为空</strong> C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 <strong>int rand(void);</strong></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>指针指向 void</strong> 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 <strong>void *malloc( size_t size );</strong> 返回指向 void 的指针，可以转换为任何数据类型。</td>
</tr>
</tbody></table>
<h1 id="C-变量"><a href="#C-变量" class="headerlink" title="C 变量"></a>C 变量</h1><p>变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p>
<p>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。基于前一章讲解的基本类型，有以下几种基本的变量类型：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td align="left">通常是一个字节（八位）, 这是一个整数类型。</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">整型，4 个字节，取值范围 -2147483648 到 2147483647。</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。<img data-src="https://www.runoob.com/wp-content/uploads/2014/09/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png" alt="img"></td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">双精度浮点值。双精度是1位符号，11位指数，52位小数。<img data-src="https://www.runoob.com/wp-content/uploads/2014/09/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.png" alt="img"></td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">表示类型的缺失。</td>
</tr>
</tbody></table>
<p>C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等等，这将会在后续的章节中进行讲解，本章节我们先讲解基本变量类型。</p>
<h2 id="C-中的变量定义"><a href="#C-中的变量定义" class="headerlink" title="C 中的变量定义"></a>C 中的变量定义</h2><p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type variable_list;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>type</strong> 必须是一个有效的 C 数据类型，可以是 char、w_char、int、float、double 或任何用户自定义的对象，<strong>variable_list</strong> 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>    i, j, k;</span><br><span class="line"><span class="type">char</span>   c, ch;</span><br><span class="line"><span class="type">float</span>  f, salary;</span><br><span class="line"><span class="type">double</span> d;</span><br></pre></td></tr></table></figure>

<p>行 <strong>int i, j, k;</strong> 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。</p>
<p>变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type variable_name = value;</span><br></pre></td></tr></table></figure>

<p>下面列举几个实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> d = <span class="number">3</span>, f = <span class="number">5</span>;    <span class="comment">// d 和 f 的声明与初始化</span></span><br><span class="line"><span class="type">int</span> d = <span class="number">3</span>, f = <span class="number">5</span>;           <span class="comment">// 定义并初始化 d 和 f</span></span><br><span class="line">byte z = <span class="number">22</span>;                <span class="comment">// 定义并初始化 z</span></span><br><span class="line"><span class="type">char</span> x = <span class="string">&#x27;x&#x27;</span>;               <span class="comment">// 变量 x 的值为 &#x27;x&#x27;</span></span><br></pre></td></tr></table></figure>

<p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p>
<h2 id="C-中的变量声明"><a href="#C-中的变量声明" class="headerlink" title="C 中的变量声明"></a>C 中的变量声明</h2><p>变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<p>变量的声明有两种情况：</p>
<ul>
<li>1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。</li>
<li>2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。</li>
<li>除非有extern关键字，否则都是变量的定义。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">//声明，不是定义</span></span><br><span class="line"><span class="type">int</span> i; <span class="comment">//声明，也是定义</span></span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<p>尝试下面的实例，其中，变量在头部就已经被声明，但是定义与初始化在主函数内：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数外定义变量 x 和 y</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="type">int</span> <span class="title function_">addtwonum</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 函数内声明变量 x 和 y 为外部变量</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="comment">// 给外部变量（全局变量）x 和 y 赋值</span></span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="comment">// 调用函数 addtwonum</span></span><br><span class="line">    result = addtwonum();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result 为: %d&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result 为: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。</p>
<h2 id="addtwonum-c-文件代码："><a href="#addtwonum-c-文件代码：" class="headerlink" title="addtwonum.c 文件代码："></a>addtwonum.c 文件代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*外部变量声明*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x ;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> y ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">addtwonum</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="test-c-文件代码："><a href="#test-c-文件代码：" class="headerlink" title="test.c 文件代码："></a>test.c 文件代码：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/*定义两个全局变量*/</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> y=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">addtwonum</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    result = addtwonum();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result 为: %d\n&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc addtwonum.c test.c -o main</span><br><span class="line">$ ./main</span><br><span class="line">result 为: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="C-中的左值（Lvalues）和右值（Rvalues）"><a href="#C-中的左值（Lvalues）和右值（Rvalues）" class="headerlink" title="C 中的左值（Lvalues）和右值（Rvalues）"></a>C 中的左值（Lvalues）和右值（Rvalues）</h2><p>C 中有两种类型的表达式：</p>
<ol>
<li><strong>左值（lvalue）：</strong>指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>
<li><strong>右值（rvalue）：</strong>术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>
</ol>
<p>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>但是下面这个就不是一个有效的语句，会生成编译时错误：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<h1 id="C-常量"><a href="#C-常量" class="headerlink" title="C 常量"></a>C 常量</h1><p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做<strong>字面量</strong>。</p>
<p>常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。</p>
<p><strong>常量</strong>就像是常规的变量，只不过常量的值在定义后不能进行修改。</p>
<h2 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h2><p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p>
<p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p>
<p>下面列举几个整数常量的实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">212</span>         <span class="comment">/* 合法的 */</span></span><br><span class="line"><span class="number">215u</span>        <span class="comment">/* 合法的 */</span></span><br><span class="line"><span class="number">0xFee</span>L      <span class="comment">/* 合法的 */</span></span><br><span class="line"><span class="number">078</span>         <span class="comment">/* 非法的：8 不是八进制的数字 */</span></span><br><span class="line"><span class="number">032U</span>U       <span class="comment">/* 非法的：不能重复后缀 */</span></span><br></pre></td></tr></table></figure>

<p>以下是各种类型的整数常量的实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">85</span>         <span class="comment">/* 十进制 */</span></span><br><span class="line"><span class="number">0213</span>       <span class="comment">/* 八进制 */</span></span><br><span class="line"><span class="number">0x4b</span>       <span class="comment">/* 十六进制 */</span></span><br><span class="line"><span class="number">30</span>         <span class="comment">/* 整数 */</span></span><br><span class="line"><span class="number">30u</span>        <span class="comment">/* 无符号整数 */</span></span><br><span class="line"><span class="number">30l</span>        <span class="comment">/* 长整数 */</span></span><br><span class="line"><span class="number">30ul</span>       <span class="comment">/* 无符号长整数 */</span></span><br></pre></td></tr></table></figure>

<h2 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h2><p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p>
<p>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p>
<p>下面列举几个浮点常量的实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14159</span>       <span class="comment">/* 合法的 */</span></span><br><span class="line"><span class="number">314159E-5</span>L    <span class="comment">/* 合法的 */</span></span><br><span class="line"><span class="number">510</span>E          <span class="comment">/* 非法的：不完整的指数 */</span></span><br><span class="line"><span class="number">210f</span>          <span class="comment">/* 非法的：没有小数或指数 */</span></span><br><span class="line">.e55          <span class="comment">/* 非法的：缺少整数或分数 */</span></span><br></pre></td></tr></table></figure>

<h2 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h2><p>字符常量是括在单引号中，例如，’x’ 可以存储在 <strong>char</strong> 类型的简单变量中。</p>
<p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\t’），或一个通用的字符（例如 ‘\u02C0’）。</p>
<p>在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：</p>
<table>
<thead>
<tr>
<th align="left">转义序列</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="left">\ 字符</td>
</tr>
<tr>
<td align="left">&#39;</td>
<td align="left">‘ 字符</td>
</tr>
<tr>
<td align="left">&quot;</td>
<td align="left">“ 字符</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">? 字符</td>
</tr>
<tr>
<td align="left">\a</td>
<td align="left">警报铃声</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格键</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页符</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行符</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">水平制表符</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">垂直制表符</td>
</tr>
<tr>
<td align="left">\ooo</td>
<td align="left">一到三位的八进制数</td>
</tr>
<tr>
<td align="left">\xhh . . .</td>
<td align="left">一个或多个数字的十六进制数</td>
</tr>
</tbody></table>
<p>下面的实例显示了一些转义序列字符：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello\tWorld\n\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Hello   World</span><br></pre></td></tr></table></figure>

<h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。</p>
<p>您可以使用空格做分隔符，把一个很长的字符串常量进行分行。</p>
<p>下面的实例显示了一些字符串常量。下面这三种形式所显示的字符串是相同的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;hello, dear&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;hello, \</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dear&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;hello, &quot;</span> <span class="string">&quot;d&quot;</span> <span class="string">&quot;ear&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>在 C 中，有两种简单的定义常量的方式：</p>
<ol>
<li>使用 <strong>#define</strong> 预处理器。</li>
<li>使用 <strong>const</strong> 关键字。</li>
</ol>
<h3 id="define-预处理器"><a href="#define-预处理器" class="headerlink" title="#define 预处理器"></a>#define 预处理器</h3><p>下面是使用 #define 预处理器定义常量的形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> identifier value</span></span><br></pre></td></tr></table></figure>

<p>具体请看下面的实例：</p>
<p>实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 10   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDTH  5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWLINE <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="type">int</span> area;  </span><br><span class="line">  </span><br><span class="line">   area = LENGTH * WIDTH;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;value of area : %d&quot;</span>, area);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, NEWLINE);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">value of area : <span class="number">50</span></span><br></pre></td></tr></table></figure>

<h3 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h3><p>您可以使用 <strong>const</strong> 前缀声明指定类型的常量，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> type variable = value;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/09/c-const-2021-01-15.png" alt="img"></p>
<p>const 声明常量要在一个语句内完成：</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/09/c-const-2021-01-15-2.png" alt="img"></p>
<p>具体请看下面的实例：</p>
<p>实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span>  LENGTH = <span class="number">10</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span>  WIDTH  = <span class="number">5</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> NEWLINE = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   <span class="type">int</span> area;  </span><br><span class="line">   </span><br><span class="line">   area = LENGTH * WIDTH;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;value of area : %d&quot;</span>, area);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, NEWLINE);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">value of area : <span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>请注意，把常量定义为大写字母形式，是一个很好的编程习惯。</p>
<h1 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C 存储类"></a>C 存储类</h1><p>存储类定义 C 程序中变量&#x2F;函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
</ul>
<h2 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h2><p><strong>auto</strong> 存储类是所有局部变量默认的存储类。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> mount;</span><br><span class="line">   <span class="keyword">auto</span> <span class="type">int</span> month;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。</p>
<h2 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h2><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">register</span> <span class="type">int</span>  miles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>
<h2 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h2><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>
<p>全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。</p>
<p>以下实例演示了 static 修饰全局变量和局部变量的应用：</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count=<span class="number">10</span>;        <span class="comment">/* 全局变量 - static 是默认的 */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">      func1();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* &#x27;thingy&#x27; 是 &#x27;func1&#x27; 的局部变量 - 只初始化一次</span></span><br><span class="line"><span class="comment"> * 每次调用函数 &#x27;func1&#x27; &#x27;thingy&#x27; 值不会被重置。</span></span><br><span class="line"><span class="comment"> */</span>                </span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> thingy=<span class="number">5</span>;</span><br><span class="line">  thingy++;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; thingy 为 %d ， count 为 %d\n&quot;</span>, thingy, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置。</p>
<p>可能您现在还无法理解这个实例，因为我已经使用了函数和全局变量，这两个概念目前为止还没进行讲解。即使您现在不能完全理解，也没有关系，后续的章节我们会详细讲解。当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">thingy</span> 为 <span class="number">6</span> ， count 为 <span class="number">9</span></span><br><span class="line"><span class="attribute">thingy</span> 为 <span class="number">7</span> ， count 为 <span class="number">8</span></span><br><span class="line"><span class="attribute">thingy</span> 为 <span class="number">8</span> ， count 为 <span class="number">7</span></span><br><span class="line"><span class="attribute">thingy</span> 为 <span class="number">9</span> ， count 为 <span class="number">6</span></span><br><span class="line"><span class="attribute">thingy</span> 为 <span class="number">10</span> ， count 为 <span class="number">5</span></span><br><span class="line"><span class="attribute">thingy</span> 为 <span class="number">11</span> ， count 为 <span class="number">4</span></span><br><span class="line"><span class="attribute">thingy</span> 为 <span class="number">12</span> ， count 为 <span class="number">3</span></span><br><span class="line"><span class="attribute">thingy</span> 为 <span class="number">13</span> ， count 为 <span class="number">2</span></span><br><span class="line"><span class="attribute">thingy</span> 为 <span class="number">14</span> ， count 为 <span class="number">1</span></span><br><span class="line"><span class="attribute">thingy</span> 为 <span class="number">15</span> ， count 为 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h2><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 <strong>extern</strong> 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p>
<p><strong>第一个文件：main.c</strong></p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> count ;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">write_extern</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   count = <span class="number">5</span>;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二个文件：support.c</strong></p>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">write_extern</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;count is %d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.c 中定义的 <em>count</em>。现在 ，编译这两个文件，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ gcc main.c support.c</span><br></pre></td></tr></table></figure>

<p>这会产生 <strong>a.out</strong> 可执行程序，当程序被执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">count is <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h1 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C 运算符"></a>C 运算符</h1><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符</li>
</ul>
<p>本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>下表显示了 C 语言支持的所有算术运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">把两个操作数相加</td>
<td align="left">A + B 将得到 30</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">从第一个操作数中减去第二个操作数</td>
<td align="left">A - B 将得到 -10</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">把两个操作数相乘</td>
<td align="left">A * B 将得到 200</td>
</tr>
<tr>
<td align="left">&#x2F;</td>
<td align="left">分子除以分母</td>
<td align="left">B &#x2F; A 将得到 2</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取模运算符，整除后的余数</td>
<td align="left">B % A 将得到 0</td>
</tr>
<tr>
<td align="left">++</td>
<td align="left">自增运算符，整数值增加 1</td>
<td align="left">A++ 将得到 11</td>
</tr>
<tr>
<td align="left">–</td>
<td align="left">自减运算符，整数值减少 1</td>
<td align="left">A– 将得到 9</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<p><strong>请看下面的实例</strong>，了解 C 语言中所有可用的算术运算符：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">21</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">   <span class="type">int</span> c ;</span><br><span class="line"> </span><br><span class="line">   c = a + b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a - b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a * b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a / b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 4 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a % b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 5 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a++;  <span class="comment">// 赋值后再加 1 ，c 为 21，a 为 22</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 6 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   c = a--;  <span class="comment">// 赋值后再减 1 ，c 为 22 ，a 为 21</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 7 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Line</span> <span class="number">1</span> - c 的值是 <span class="number">31</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">2</span> - c 的值是 <span class="number">11</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">3</span> - c 的值是 <span class="number">210</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">4</span> - c 的值是 <span class="number">2</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">5</span> - c 的值是 <span class="number">1</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">6</span> - c 的值是 <span class="number">21</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">7</span> - c 的值是 <span class="number">22</span></span><br></pre></td></tr></table></figure>

<p>以下实例演示了 a++ 与 ++a 的区别：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> c;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">   c = a++; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;先赋值后运算：\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - a 的值是 %d\n&quot;</span>, a );</span><br><span class="line">   a = <span class="number">10</span>;</span><br><span class="line">   c = a--; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 4 - a 的值是 %d\n&quot;</span>, a );</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;先运算后赋值：\n&quot;</span>);</span><br><span class="line">   a = <span class="number">10</span>;</span><br><span class="line">   c = ++a; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 5 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 6 - a 的值是 %d\n&quot;</span>, a );</span><br><span class="line">   a = <span class="number">10</span>;</span><br><span class="line">   c = --a; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 7 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 8 - a 的值是 %d\n&quot;</span>, a );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上程序执行输出结果为：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">先赋值后运算：</span><br><span class="line"><span class="built_in">Line</span> <span class="number">1</span> <span class="operator">-</span> <span class="variable">c</span> 的值是 <span class="number">10</span></span><br><span class="line"><span class="built_in">Line</span> <span class="number">2</span> <span class="operator">-</span> <span class="variable">a</span> 的值是 <span class="number">11</span></span><br><span class="line"><span class="built_in">Line</span> <span class="number">3</span> <span class="operator">-</span> <span class="variable">c</span> 的值是 <span class="number">10</span></span><br><span class="line"><span class="built_in">Line</span> <span class="number">4</span> <span class="operator">-</span> <span class="variable">a</span> 的值是 <span class="number">9</span></span><br><span class="line">先运算后赋值：</span><br><span class="line"><span class="built_in">Line</span> <span class="number">5</span> <span class="operator">-</span> <span class="variable">c</span> 的值是 <span class="number">11</span></span><br><span class="line"><span class="built_in">Line</span> <span class="number">6</span> <span class="operator">-</span> <span class="variable">a</span> 的值是 <span class="number">11</span></span><br><span class="line"><span class="built_in">Line</span> <span class="number">7</span> <span class="operator">-</span> <span class="variable">c</span> 的值是 <span class="number">9</span></span><br><span class="line"><span class="built_in">Line</span> <span class="number">8</span> <span class="operator">-</span> <span class="variable">a</span> 的值是 <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>下表显示了 C 语言支持的所有关系运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;</td>
<td align="left">检查两个操作数的值是否相等，如果相等则条件为真。</td>
<td align="left">(A &#x3D;&#x3D; B) 为假。</td>
</tr>
<tr>
<td align="left">!&#x3D;</td>
<td align="left">检查两个操作数的值是否相等，如果不相等则条件为真。</td>
<td align="left">(A !&#x3D; B) 为真。</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &gt; B) 为假。</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &lt; B) 为真。</td>
</tr>
<tr>
<td align="left">&gt;&#x3D;</td>
<td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &gt;&#x3D; B) 为假。</td>
</tr>
<tr>
<td align="left">&lt;&#x3D;</td>
<td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>
<td align="left">(A &lt;&#x3D; B) 为真。</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<p>请看下面的实例，了解 C 语言中所有可用的关系运算符：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">21</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">   <span class="type">int</span> c ;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>( a == b )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - a 等于 b\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - a 不等于 b\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( a &lt; b )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - a 小于 b\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - a 不小于 b\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( a &gt; b )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - a 大于 b\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - a 不大于 b\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 改变 a 和 b 的值 */</span></span><br><span class="line">   a = <span class="number">5</span>;</span><br><span class="line">   b = <span class="number">20</span>;</span><br><span class="line">   <span class="keyword">if</span> ( a &lt;= b )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 4 - a 小于或等于 b\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( b &gt;= a )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 5 - b 大于或等于 a\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">Line <span class="number">1</span> - <span class="selector-tag">a</span> 不等于 <span class="selector-tag">b</span></span><br><span class="line">Line <span class="number">2</span> - <span class="selector-tag">a</span> 不小于 <span class="selector-tag">b</span></span><br><span class="line">Line <span class="number">3</span> - <span class="selector-tag">a</span> 大于 <span class="selector-tag">b</span></span><br><span class="line">Line <span class="number">4</span> - <span class="selector-tag">a</span> 小于或等于 <span class="selector-tag">b</span></span><br><span class="line">Line <span class="number">5</span> - <span class="selector-tag">b</span> 大于或等于 <span class="selector-tag">a</span></span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 <strong>A</strong> 的值为 1，变量 <strong>B</strong> 的值为 0，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>
<td align="left">(A &amp;&amp; B) 为假。</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>
<td align="left">(A || B) 为真。</td>
</tr>
<tr>
<td align="left">!</td>
<td align="left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td align="left">!(A &amp;&amp; B) 为真。</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<p>请看下面的实例，了解 C 语言中所有可用的逻辑运算符：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">   <span class="type">int</span> c ;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> ( a &amp;&amp; b )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - 条件为真\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( a || b )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - 条件为真\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 改变 a 和 b 的值 */</span></span><br><span class="line">   a = <span class="number">0</span>;</span><br><span class="line">   b = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">if</span> ( a &amp;&amp; b )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - 条件为真\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - 条件为假\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( !(a &amp;&amp; b) )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Line 4 - 条件为真\n&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Line</span> <span class="number">1</span> - 条件为真</span><br><span class="line"><span class="attribute">Line</span> <span class="number">2</span> - 条件为真</span><br><span class="line"><span class="attribute">Line</span> <span class="number">3</span> - 条件为假</span><br><span class="line"><span class="attribute">Line</span> <span class="number">4</span> - 条件为真</span><br></pre></td></tr></table></figure>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>
<table>
<thead>
<tr>
<th align="left">p</th>
<th align="left">q</th>
<th align="left">p &amp; q</th>
<th align="left">p | q</th>
<th align="left">p ^ q</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>假设如果 A &#x3D; 60，且 B &#x3D; 13，现在以二进制格式表示，它们如下所示：</p>
<p>A &#x3D; 0011 1100</p>
<p>B &#x3D; 0000 1101</p>
<p>-—————-</p>
<p>A&amp;B &#x3D; 0000 1100</p>
<p>A|B &#x3D; 0011 1101</p>
<p>A^B &#x3D; 0011 0001</p>
<p>~A &#x3D; 1100 0011</p>
<p>下表显示了 C 语言支持的位运算符。假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">按位与操作，按二进制位进行”与”运算。运算规则：<code>0&amp;0=0;    0&amp;1=0;     1&amp;0=0;      1&amp;1=1;</code></td>
<td align="left">(A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">按位或运算符，按二进制位进行”或”运算。运算规则：&#96;0</td>
<td align="left">0&#x3D;0;    0</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">异或运算符，按二进制位进行”异或”运算。运算规则：<code>0^0=0;    0^1=1;    1^0=1;   1^1=0;</code></td>
<td align="left">(A ^ B) 将得到 49，即为 0011 0001</td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">取反运算符，按二进制位进行”取反”运算。运算规则：<code>~1=-2;    ~0=-1;</code></td>
<td align="left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</td>
<td align="left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</td>
<td align="left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<p>请看下面的实例，了解 C 语言中所有可用的位运算符：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">60</span>;    <span class="comment">/* 60 = 0011 1100 */</span>  </span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">13</span>;    <span class="comment">/* 13 = 0000 1101 */</span></span><br><span class="line">   <span class="type">int</span> c = <span class="number">0</span>;           </span><br><span class="line"> </span><br><span class="line">   c = a &amp; b;       <span class="comment">/* 12 = 0000 1100 */</span> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c = a | b;       <span class="comment">/* 61 = 0011 1101 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c = a ^ b;       <span class="comment">/* 49 = 0011 0001 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c = ~a;          <span class="comment">/*-61 = 1100 0011 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 4 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c = a &lt;&lt; <span class="number">2</span>;     <span class="comment">/* 240 = 1111 0000 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 5 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c = a &gt;&gt; <span class="number">2</span>;     <span class="comment">/* 15 = 0000 1111 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 6 - c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Line</span> <span class="number">1</span> - c 的值是 <span class="number">12</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">2</span> - c 的值是 <span class="number">61</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">3</span> - c 的值是 <span class="number">49</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">4</span> - c 的值是 -<span class="number">61</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">5</span> - c 的值是 <span class="number">240</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">6</span> - c 的值是 <span class="number">15</span></span><br></pre></td></tr></table></figure>

<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>下表列出了 C 语言支持的赋值运算符：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;</td>
<td align="left">简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
<td align="left">C &#x3D; A + B 将把 A + B 的值赋给 C</td>
</tr>
<tr>
<td align="left">+&#x3D;</td>
<td align="left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
<td align="left">C +&#x3D; A 相当于 C &#x3D; C + A</td>
</tr>
<tr>
<td align="left">-&#x3D;</td>
<td align="left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
<td align="left">C -&#x3D; A 相当于 C &#x3D; C - A</td>
</tr>
<tr>
<td align="left">*&#x3D;</td>
<td align="left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
<td align="left">C *&#x3D; A 相当于 C &#x3D; C * A</td>
</tr>
<tr>
<td align="left">&#x2F;&#x3D;</td>
<td align="left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
<td align="left">C &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A</td>
</tr>
<tr>
<td align="left">%&#x3D;</td>
<td align="left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
<td align="left">C %&#x3D; A 相当于 C &#x3D; C % A</td>
</tr>
<tr>
<td align="left">&lt;&lt;&#x3D;</td>
<td align="left">左移且赋值运算符</td>
<td align="left">C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</td>
</tr>
<tr>
<td align="left">&gt;&gt;&#x3D;</td>
<td align="left">右移且赋值运算符</td>
<td align="left">C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</td>
</tr>
<tr>
<td align="left">&amp;&#x3D;</td>
<td align="left">按位与且赋值运算符</td>
<td align="left">C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</td>
</tr>
<tr>
<td align="left">^&#x3D;</td>
<td align="left">按位异或且赋值运算符</td>
<td align="left">C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</td>
</tr>
<tr>
<td align="left">|&#x3D;</td>
<td align="left">按位或且赋值运算符</td>
<td align="left">C |&#x3D; 2 等同于 C &#x3D; C | 2</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<p>请看下面的实例，了解 C 语言中所有可用的赋值运算符：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">21</span>;</span><br><span class="line">   <span class="type">int</span> c ;</span><br><span class="line"> </span><br><span class="line">   c =  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - =  运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c +=  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - += 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c -=  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - -= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c *=  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 4 - *= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c /=  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 5 - /= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c  = <span class="number">200</span>;</span><br><span class="line">   c %=  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 6 - %%= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c &lt;&lt;=  <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 7 - &lt;&lt;= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c &gt;&gt;=  <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 8 - &gt;&gt;= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c &amp;=  <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 9 - &amp;= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c ^=  <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 10 - ^= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">   c |=  <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 11 - |= 运算符实例，c 的值 = %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Line</span> <span class="number">1</span> - =  运算符实例，c 的值 = <span class="number">21</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">2</span> - += 运算符实例，c 的值 = <span class="number">42</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">3</span> - -= 运算符实例，c 的值 = <span class="number">21</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">4</span> - *= 运算符实例，c 的值 = <span class="number">441</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">5</span> - /= 运算符实例，c 的值 = <span class="number">21</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">6</span> - %= 运算符实例，c 的值 = <span class="number">11</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">7</span> - &lt;&lt;= 运算符实例，c 的值 = <span class="number">44</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">8</span> - &gt;&gt;= 运算符实例，c 的值 = <span class="number">11</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">9</span> - &amp;= 运算符实例，c 的值 = <span class="number">2</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">10</span> - ^= 运算符实例，c 的值 = <span class="number">0</span></span><br><span class="line"><span class="attribute">Line</span> <span class="number">11</span> - |= 运算符实例，c 的值 = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="杂项运算符-↦-sizeof-amp-三元"><a href="#杂项运算符-↦-sizeof-amp-三元" class="headerlink" title="杂项运算符 ↦ sizeof &amp; 三元"></a>杂项运算符 ↦ sizeof &amp; 三元</h2><p>下表列出了 C 语言支持的其他一些重要的运算符，包括 <strong>sizeof</strong> 和 **? :**。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sizeof()</td>
<td align="left">返回变量的大小。</td>
<td align="left">sizeof(a) 将返回 4，其中 a 是整数。</td>
</tr>
<tr>
<td align="left">&amp;</td>
<td align="left">返回变量的地址。</td>
<td align="left">&amp;a; 将给出变量的实际地址。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">指向一个变量。</td>
<td align="left">*a; 将指向一个变量。</td>
</tr>
<tr>
<td align="left">? :</td>
<td align="left">条件表达式</td>
<td align="left">如果条件为真 ? 则值为 X : 否则值为 Y</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<p>请看下面的实例，了解 C 语言中所有可用的杂项运算符：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line">   <span class="type">short</span> b;</span><br><span class="line">   <span class="type">double</span> c;</span><br><span class="line">   <span class="type">int</span>* ptr;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* sizeof 运算符实例 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 1 - 变量 a 的大小 = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(a) );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 2 - 变量 b 的大小 = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(b) );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line 3 - 变量 c 的大小 = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(c) );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* &amp; 和 * 运算符实例 */</span></span><br><span class="line">   ptr = &amp;a;    <span class="comment">/* &#x27;ptr&#x27; 现在包含 &#x27;a&#x27; 的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a 的值是 %d\n&quot;</span>, a);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;*ptr 是 %d\n&quot;</span>, *ptr);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 三元运算符实例 */</span></span><br><span class="line">   a = <span class="number">10</span>;</span><br><span class="line">   b = (a == <span class="number">1</span>) ? <span class="number">20</span>: <span class="number">30</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;b 的值是 %d\n&quot;</span>, b );</span><br><span class="line"> </span><br><span class="line">   b = (a == <span class="number">10</span>) ? <span class="number">20</span>: <span class="number">30</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;b 的值是 %d\n&quot;</span>, b );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">Line <span class="number">1</span> - 变量 <span class="selector-tag">a</span> 的大小 = <span class="number">4</span></span><br><span class="line">Line <span class="number">2</span> - 变量 <span class="selector-tag">b</span> 的大小 = <span class="number">2</span></span><br><span class="line">Line <span class="number">3</span> - 变量 c 的大小 = <span class="number">8</span></span><br><span class="line"><span class="selector-tag">a</span> 的值是 <span class="number">4</span></span><br><span class="line">*ptr 是 <span class="number">4</span></span><br><span class="line"><span class="selector-tag">b</span> 的值是 <span class="number">30</span></span><br><span class="line"><span class="selector-tag">b</span> 的值是 <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h2 id="C-中的运算符优先级"><a href="#C-中的运算符优先级" class="headerlink" title="C 中的运算符优先级"></a>C 中的运算符优先级</h2><p>运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。</p>
<p>例如 x &#x3D; 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。</p>
<p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">运算符</th>
<th align="left">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">后缀</td>
<td align="left">() [] -&gt; . ++ - -</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">一元</td>
<td align="left">+ - ! ~ ++ - - (type)* &amp; sizeof</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">乘除</td>
<td align="left">* &#x2F; %</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">加减</td>
<td align="left">+ -</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">移位</td>
<td align="left">&lt;&lt; &gt;&gt;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">关系</td>
<td align="left">&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">相等</td>
<td align="left">&#x3D;&#x3D; !&#x3D;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位与 AND</td>
<td align="left">&amp;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位异或 XOR</td>
<td align="left">^</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位或 OR</td>
<td align="left">|</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">逻辑与 AND</td>
<td align="left">&amp;&amp;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">逻辑或 OR</td>
<td align="left">||</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">条件</td>
<td align="left">?:</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">赋值</td>
<td align="left">&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">逗号</td>
<td align="left">,</td>
<td align="left">从左到右</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<p>请看下面的实例，了解 C 语言中运算符的优先级：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">   <span class="type">int</span> c = <span class="number">15</span>;</span><br><span class="line">   <span class="type">int</span> d = <span class="number">5</span>;</span><br><span class="line">   <span class="type">int</span> e;</span><br><span class="line"> </span><br><span class="line">   e = (a + b) * c / d;      <span class="comment">// ( 30 * 15 ) / 5</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;(a + b) * c / d 的值是 %d\n&quot;</span>,  e );</span><br><span class="line"> </span><br><span class="line">   e = ((a + b) * c) / d;    <span class="comment">// (30 * 15 ) / 5</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;((a + b) * c) / d 的值是 %d\n&quot;</span> ,  e );</span><br><span class="line"> </span><br><span class="line">   e = (a + b) * (c / d);   <span class="comment">// (30) * (15/5)</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;(a + b) * (c / d) 的值是 %d\n&quot;</span>,  e );</span><br><span class="line"> </span><br><span class="line">   e = a + (b * c) / d;     <span class="comment">//  20 + (150/5)</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a + (b * c) / d 的值是 %d\n&quot;</span> ,  e );</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">(<span class="selector-tag">a</span> + <span class="selector-tag">b</span>) * c / d 的值是 <span class="number">90</span></span><br><span class="line">((<span class="selector-tag">a</span> + <span class="selector-tag">b</span>) * c) / d 的值是 <span class="number">90</span></span><br><span class="line">(<span class="selector-tag">a</span> + <span class="selector-tag">b</span>) * (c / d) 的值是 <span class="number">90</span></span><br><span class="line"><span class="selector-tag">a</span> + (<span class="selector-tag">b</span> * c) / d 的值是 <span class="number">50</span></span><br></pre></td></tr></table></figure>

<h1 id="C-判断"><a href="#C-判断" class="headerlink" title="C 判断"></a>C 判断</h1><p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p>
<p>C 语言把任何<strong>非零</strong>和<strong>非空</strong>的值假定为 <strong>true</strong>，把<strong>零</strong>或 <strong>null</strong> 假定为 <strong>false</strong>。</p>
<p>下面是大多数编程语言中典型的判断结构的一般形式：</p>
<p><img data-src="https://static.runoob.com/wp-content/uploads/c/C-decision-20200923-1.svg" alt="C 中的判断语句"></p>
<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>C 语言提供了以下类型的判断语句。点击链接查看每个语句的细节。</p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-if.html">if 语句</a></td>
<td align="left">一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-if-else.html">if…else 语句</a></td>
<td align="left">一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-nested-if.html">嵌套 if 语句</a></td>
<td align="left">您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-switch.html">switch 语句</a></td>
<td align="left">一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-nested-switch.html">嵌套 switch 语句</a></td>
<td align="left">您可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch</strong> 语句。</td>
</tr>
</tbody></table>
<h2 id="运算符-三元运算符"><a href="#运算符-三元运算符" class="headerlink" title="? : 运算符(三元运算符)"></a>? : 运算符(三元运算符)</h2><p>我们已经在前面的章节中讲解了 **条件运算符 ? :**，可以用来替代 <strong>if…else</strong> 语句。它的一般形式如下：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">Exp1 ? Exp2<span class="keyword"> :</span> Exp3;</span><br></pre></td></tr></table></figure>

<p>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</p>
<p>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个表达式的值。</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/09/Conditional-Statement-in-C-Programming-Lanuage-Ternary-Operator.png" alt="img"></p>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>以下实例通过输入一个数字来判断它是否为奇数或偶数</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入一个数字 : &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line"> </span><br><span class="line">    (num%<span class="number">2</span>==<span class="number">0</span>)?<span class="built_in">printf</span>(<span class="string">&quot;偶数&quot;</span>):<span class="built_in">printf</span>(<span class="string">&quot;奇数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-循环"><a href="#C-循环" class="headerlink" title="C 循环"></a>C 循环</h1><p>有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。</p>
<p>编程语言提供了更为复杂执行路径的多种控制结构。</p>
<p>循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的流程图：</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2015/12/loop.png" alt="循环结构"></p>
<h2 id="循环类型"><a href="#循环类型" class="headerlink" title="循环类型"></a>循环类型</h2><p>C 语言提供了以下几种循环类型。点击链接查看每个类型的细节。</p>
<table>
<thead>
<tr>
<th align="left">循环类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-while-loop.html">while 循环</a></td>
<td align="left">当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-for-loop.html">for 循环</a></td>
<td align="left">多次执行一个语句序列，简化管理循环变量的代码。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-do-while-loop.html">do…while 循环</a></td>
<td align="left">除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-nested-loops.html">嵌套循环</a></td>
<td align="left">您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td>
</tr>
</tbody></table>
<h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><p>循环控制语句改变你代码的执行顺序。通过它你可以实现代码的跳转。</p>
<p>C 提供了下列的循环控制语句。点击链接查看每个语句的细节。</p>
<table>
<thead>
<tr>
<th align="left">控制语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-break-statement.html">break 语句</a></td>
<td align="left">终止<strong>循环</strong>或 <strong>switch</strong> 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-continue-statement.html">continue 语句</a></td>
<td align="left">告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-goto-statement.html">goto 语句</a></td>
<td align="left">将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td>
</tr>
</tbody></table>
<h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>如果条件永远不为假，则循环将变成无限循环。<strong>for</strong> 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>( ; ; )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;该循环会永远执行下去！\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C 程序员偏向于使用 for(;;) 结构来表示一个无限循环。</p>
<p><strong>注意：</strong>您可以按 <strong>Ctrl + C</strong> 键终止一个无限循环。</p>
<h2 id="Goto"><a href="#Goto" class="headerlink" title="Goto"></a>Goto</h2><p>C 语言中的 <strong>goto</strong> 语句允许把控制无条件转移到同一函数内的被标记的语句。</p>
<p><strong>注意：</strong>在任何编程语言中，都不建议使用 goto 语句。因为它使得程序的控制流难以跟踪，使程序难以理解和难以修改。任何使用 goto 语句的程序可以改写成不需要使用 goto 语句的写法。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>C 语言中 <strong>goto</strong> 语句的语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">goto <span class="selector-tag">label</span>;</span><br><span class="line">..</span><br><span class="line">.</span><br><span class="line"><span class="selector-tag">label</span>: statement;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>label</strong> 可以是任何除 C 关键字以外的纯文本，它可以设置在 C 程序中 <strong>goto</strong> 语句的前面或者后面。</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2015/01/goto.png" alt="img"></p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img data-src="https://www.runoob.com/wp-content/uploads/2014/09/c-goto-20200923-1.png" alt="C goto 语句"></p>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">   <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* do 循环执行 */</span></span><br><span class="line">   LOOP:<span class="keyword">do</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>( a == <span class="number">15</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">/* 跳过迭代 */</span></span><br><span class="line">         a = a + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">goto</span> LOOP;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;a 的值： %d\n&quot;</span>, a);</span><br><span class="line">      a++;</span><br><span class="line">     </span><br><span class="line">   &#125;<span class="keyword">while</span>( a &lt; <span class="number">20</span> );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">a</span> 的值： <span class="number">10</span></span><br><span class="line"><span class="attribute">a</span> 的值： <span class="number">11</span></span><br><span class="line"><span class="attribute">a</span> 的值： <span class="number">12</span></span><br><span class="line"><span class="attribute">a</span> 的值： <span class="number">13</span></span><br><span class="line"><span class="attribute">a</span> 的值： <span class="number">14</span></span><br><span class="line"><span class="attribute">a</span> 的值： <span class="number">16</span></span><br><span class="line"><span class="attribute">a</span> 的值： <span class="number">17</span></span><br><span class="line"><span class="attribute">a</span> 的值： <span class="number">18</span></span><br><span class="line"><span class="attribute">a</span> 的值： <span class="number">19</span></span><br></pre></td></tr></table></figure>

<h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C 函数"></a>C 函数</h1><p>函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 <strong>main()</strong> ，所有简单的程序都可以定义其他额外的函数。</p>
<p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p>
<p>函数<strong>声明</strong>告诉编译器函数的名称、返回类型和参数。函数<strong>定义</strong>提供了函数的实际主体。</p>
<p>C 标准库提供了大量的程序可以调用的内置函数。例如，函数 <strong>strcat()</strong> 用来连接两个字符串，函数 <strong>memcpy()</strong> 用来复制内存到另一个位置。</p>
<p>函数还有很多叫法，比如方法、子例程或程序，等等。</p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>C 语言中的函数定义的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p>
<ul>
<li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li>
<li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>
<li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>
<li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li>
</ul>
<p><strong>实例</strong></p>
<p>以下是 <strong>max()</strong> 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 函数返回两个数中较大的那个数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">   <span class="type">int</span> result;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>函数<strong>声明</strong>会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<p>函数声明包括以下几个部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span>;</span><br></pre></td></tr></table></figure>

<p>针对上面定义的函数 max()，以下是函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br></pre></td></tr></table></figure>

<p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。</p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</p>
<p>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</p>
<p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">   <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">   <span class="type">int</span> ret;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 调用函数来获取最大值 */</span></span><br><span class="line">   ret = max(a, b);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Max value is : %d\n&quot;</span>, ret );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数返回两个数中较大的那个数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">   <span class="type">int</span> result;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">      result = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      result = num2;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Max value <span class="keyword">is</span> : 200</span><br></pre></td></tr></table></figure>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>
<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>
<p>当调用函数时，有两种向函数传递参数的方式：</p>
<table>
<thead>
<tr>
<th align="left">调用类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-call-by-value.html">传值调用</a></td>
<td align="left">该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-function-call-by-pointer.html">引用调用</a></td>
<td align="left">通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</td>
</tr>
</tbody></table>
<p>默认情况下，C 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。</p>
<h1 id="C-作用域规则"><a href="#C-作用域规则" class="headerlink" title="C 作用域规则"></a>C 作用域规则</h1><p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：</p>
<ol>
<li>在函数或块内部的<strong>局部</strong>变量</li>
<li>在所有函数外部的<strong>全局</strong>变量</li>
<li>在<strong>形式</strong>参数的函数参数定义中</li>
</ol>
<p>让我们来看看什么是<strong>局部</strong>变量、<strong>全局</strong>变量和<strong>形式</strong>参数。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。下面是使用局部变量的实例。在这里，所有的变量 a、b 和 c 是 main() 函数的局部变量。</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 实际初始化 */</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  c = a + b;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and c = %d\n&quot;</span>, a, b, c);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。</p>
<p>全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。下面是使用全局变量和局部变量的实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 全局变量声明 */</span></span><br><span class="line"><span class="type">int</span> g;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 实际初始化 */</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  g = a + b;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and g = %d\n&quot;</span>, a, b, g);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用。下面是一个实例：</p>
<p>在程序中，局部变量和全局变量的</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 全局变量声明 */</span></span><br><span class="line"><span class="type">int</span> g = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">  <span class="type">int</span> g = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of g = %d\n&quot;</span>,  g);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">value of g <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h2><p>函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。下面是一个实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 全局变量声明 */</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 在主函数中的局部变量声明 */</span></span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of a in main() = %d\n&quot;</span>,  a);</span><br><span class="line">  c = sum( a, b);</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of c in main() = %d\n&quot;</span>,  c);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 添加两个整数的函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;value of a in sum() = %d\n&quot;</span>,  a);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;value of b in sum() = %d\n&quot;</span>,  b);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">value</span> of a <span class="keyword">in</span> <span class="title">main</span>()</span> = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">value</span> of a <span class="keyword">in</span> <span class="title">sum</span>()</span> = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">value</span> of b <span class="keyword">in</span> <span class="title">sum</span>()</span> = <span class="number">20</span></span><br><span class="line"><span class="function"><span class="keyword">value</span> of c <span class="keyword">in</span> <span class="title">main</span>()</span> = <span class="number">30</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>全局变量与局部变量在内存中的区别</strong>：</p>
<ul>
<li>全局变量保存在内存的全局存储区中，占用静态的存储单元；</li>
<li>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</li>
</ul>
<p>更多内容可参考：<a href="https://www.runoob.com/w3cnote/cpp-static-usage.html">C&#x2F;C++ 中 static 的用法全局变量与局部变量</a></p>
</blockquote>
<h2 id="初始化局部变量和全局变量"><a href="#初始化局部变量和全局变量" class="headerlink" title="初始化局部变量和全局变量"></a>初始化局部变量和全局变量</h2><p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">初始化默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\0’</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">pointer</td>
<td align="left">NULL</td>
</tr>
</tbody></table>
<p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。</p>
<h1 id="C-数组"><a href="#C-数组" class="headerlink" title="C 数组"></a>C 数组</h1><p>C 语言支持<strong>数组</strong>数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p>
<p>数组的声明并不是声明一个个单独的变量，比如 runoob0、runoob1、…、runoob99，而是声明一个数组变量，比如 runoob，然后使用 runoob[0]、runoob[1]、…、runoob[99] 来代表一个个单独的变量。</p>
<p>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/09/c-arrays-2021-1-18-3.png" alt="C 中的数组"></p>
<p>数组中的特定元素可以通过索引访问，第一个索引值为 0。</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/09/c-array-2021-01-18-2.png" alt="img"></p>
<h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type arrayName [ arraySize ];</span><br></pre></td></tr></table></figure>

<p>这叫做一维数组。<strong>arraySize</strong> 必须是一个大于零的整数常量，<strong>type</strong> 可以是任意有效的 C 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 <strong>balance</strong>，声明语句如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> balance[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>现在 <em>balance</em> 是一个可用的数组，可以容纳 10 个类型为 double 的数字。</p>
<h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><p>在 C 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> balance[<span class="number">5</span>] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。</p>
<p>如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> balance[] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">balance[<span class="number">4</span>] = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure>

<p>上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/09/c-arrays-2021-1-18-4.png" alt="数组表示"></p>
<p>下图是一个长度为 <strong>10</strong> 的数组，第一个元素的索引值为 <strong>0</strong>，第九个元素 <strong>runoob</strong> 的索引值为 <strong>8</strong>:</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/09/c-array-2021-01-18-2.png" alt="img"></p>
<h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> salary = balance[<span class="number">9</span>];</span><br></pre></td></tr></table></figure>

<p>上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> n[ <span class="number">10</span> ]; <span class="comment">/* n 是一个包含 10 个整数的数组 */</span></span><br><span class="line">   <span class="type">int</span> i,j;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 初始化数组元素 */</span>         </span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      n[ i ] = i + <span class="number">100</span>; <span class="comment">/* 设置元素 i 为 i + 100 */</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 输出数组中每个元素的值 */</span></span><br><span class="line">   <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Element[%d] = %d\n&quot;</span>, j, n[j] );</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Element[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">Element[<span class="number">1</span>] = <span class="number">101</span></span><br><span class="line">Element[<span class="number">2</span>] = <span class="number">102</span></span><br><span class="line">Element[<span class="number">3</span>] = <span class="number">103</span></span><br><span class="line">Element[<span class="number">4</span>] = <span class="number">104</span></span><br><span class="line">Element[<span class="number">5</span>] = <span class="number">105</span></span><br><span class="line">Element[<span class="number">6</span>] = <span class="number">106</span></span><br><span class="line">Element[<span class="number">7</span>] = <span class="number">107</span></span><br><span class="line">Element[<span class="number">8</span>] = <span class="number">108</span></span><br><span class="line">Element[<span class="number">9</span>] = <span class="number">109</span></span><br></pre></td></tr></table></figure>

<h2 id="C-中数组详解"><a href="#C-中数组详解" class="headerlink" title="C 中数组详解"></a>C 中数组详解</h2><p>在 C 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C 程序员必须清楚的一些与数组相关的重要概念：</p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-multi-dimensional-arrays.html">多维数组</a></td>
<td align="left">C 支持多维数组。多维数组最简单的形式是二维数组。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-passing-arrays-to-functions.html">传递数组给函数</a></td>
<td align="left">您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-return-arrays-from-function.html">从函数返回数组</a></td>
<td align="left">C 允许从函数返回数组。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-pointer-to-an-array.html">指向数组的指针</a></td>
<td align="left">您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</td>
</tr>
</tbody></table>
<h1 id="C-enum-枚举"><a href="#C-enum-枚举" class="headerlink" title="C enum(枚举)"></a>C enum(枚举)</h1><p>枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。</p>
<p>枚举语法定义格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MON  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TUE  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WED  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THU  4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRI  5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAT  6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUN  7</span></span><br></pre></td></tr></table></figure>



<p>这个看起来代码量就比较多，接下来我们看看使用枚举的方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样看起来是不是更简洁了。</p>
<p><strong>注意：</strong>第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p>
<blockquote>
<p>可以在定义枚举类型时改变枚举元素的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">season</span> &#123;</span>spring, summer=<span class="number">3</span>, autumn, winter&#125;;</span><br></pre></td></tr></table></figure>

<p>没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5</p>
</blockquote>
<h2 id="枚举变量的定义"><a href="#枚举变量的定义" class="headerlink" title="枚举变量的定义"></a>枚举变量的定义</h2><p>前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。</p>
<p>我们可以通过以下三种方式来定义枚举变量</p>
<p><strong>1、先定义枚举类型，再定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>2、定义枚举类型的同时定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>

<p><strong>3、省略枚举名称，直接定义枚举变量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br><span class="line">    day = WED;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,day);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。</p>
<p>不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。</p>
<p>以下实例使用 for 来遍历枚举的元素：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 遍历枚举元素</span></span><br><span class="line">    <span class="keyword">for</span> (day = MON; day &lt;= SUN; day++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;枚举元素：%d \n&quot;</span>, day);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上实例输出结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">枚举元素：1 </span><br><span class="line">枚举元素：2 </span><br><span class="line">枚举元素：3 </span><br><span class="line">枚举元素：4 </span><br><span class="line">枚举元素：5 </span><br><span class="line">枚举元素：6 </span><br><span class="line">枚举元素：7</span><br></pre></td></tr></table></figure>

<p>以下枚举类型不连续，这种枚举无法遍历。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ENUM_0,</span><br><span class="line">    ENUM_10 = <span class="number">10</span>,</span><br><span class="line">    ENUM_11</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>枚举在 switch 中的使用：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span> red=<span class="number">1</span>, green, blue &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">enum</span>  <span class="title">color</span> <span class="title">favorite_color</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 用户输入数字来选择颜色 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你喜欢的颜色: (1. red, 2. green, 3. blue): &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;favorite_color);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 输出结果 */</span></span><br><span class="line">    <span class="keyword">switch</span> (favorite_color)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> red:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你喜欢的颜色是红色&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> green:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你喜欢的颜色是绿色&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> blue:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你喜欢的颜色是蓝色&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你没有选择你喜欢的颜色&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上实例输出结果为：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">请输入你喜欢的颜色: (<span class="number">1.</span> <span class="built_in">red</span>, <span class="number">2.</span> <span class="built_in">green</span>, <span class="number">3.</span> <span class="built_in">blue</span>): <span class="number">1</span></span><br><span class="line">你喜欢的颜色是红色</span><br></pre></td></tr></table></figure>

<h2 id="将整数转换为枚举"><a href="#将整数转换为枚举" class="headerlink" title="将整数转换为枚举"></a>将整数转换为枚举</h2><p>以下实例将整数转换为枚举：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">day</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        saturday,</span><br><span class="line">        sunday,</span><br><span class="line">        monday,</span><br><span class="line">        tuesday,</span><br><span class="line">        wednesday,</span><br><span class="line">        thursday,</span><br><span class="line">        friday</span><br><span class="line">    &#125; workday;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">day</span> <span class="title">weekend</span>;</span></span><br><span class="line">    weekend = ( <span class="keyword">enum</span> day ) a;  <span class="comment">//类型转换</span></span><br><span class="line">    <span class="comment">//weekend = a; //错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;weekend:%d&quot;</span>,weekend);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上实例输出结果为：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">weekend</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C 指针"></a>C 指针</h1><p>学习 C 语言的指针既简单又有趣。通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C 程序员，学习指针是很有必要的。</p>
<p>正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用 <strong>&amp;</strong> 运算符访问的地址，它表示了在内存中的一个地址。</p>
<p>请看下面的实例，它将输出定义的变量地址：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> var_runoob = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p;              <span class="comment">// 定义指针变量</span></span><br><span class="line">    p = &amp;var_runoob;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;var_runoob 变量的地址： %p\n&quot;</span>, p);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var_runoob</span> 变量的地址： <span class="number">0</span>x7ffeeaae08d8</span><br></pre></td></tr></table></figure>

<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/09/c-pointer.png" alt="img"></p>
<p>通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。</p>
<h2 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h2><p>指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> *var_name;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>type</strong> 是指针的基类型，它必须是一个有效的 C 数据类型，<strong>var_name</strong> 是指针变量的名称。用来声明指针的星号 ***** 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>    *ip;    <span class="comment">/* 一个整型的指针 */</span></span><br><span class="line"><span class="type">double</span> *dp;    <span class="comment">/* 一个 double 型的指针 */</span></span><br><span class="line"><span class="type">float</span>  *fp;    <span class="comment">/* 一个浮点型的指针 */</span></span><br><span class="line"><span class="type">char</span>   *ch;    <span class="comment">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure>

<p>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。</p>
<p>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p>
<h2 id="如何使用指针？"><a href="#如何使用指针？" class="headerlink" title="如何使用指针？"></a>如何使用指针？</h2><p>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  var = <span class="number">20</span>;   <span class="comment">/* 实际变量的声明 */</span></span><br><span class="line">   <span class="type">int</span>  *ip;        <span class="comment">/* 指针变量的声明 */</span></span><br><span class="line"> </span><br><span class="line">   ip = &amp;var;  <span class="comment">/* 在指针变量中存储 var 的地址 */</span></span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;var 变量的地址: %p\n&quot;</span>, &amp;var  );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 在指针变量中存储的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ip 变量存储的地址: %p\n&quot;</span>, ip );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var 变量的地址: <span class="number">0x7ffeeef168d8</span></span><br><span class="line">ip 变量存储的地址: <span class="number">0x7ffeeef168d8</span></span><br><span class="line">*ip 变量的值: <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h2 id="C-中的-NULL-指针"><a href="#C-中的-NULL-指针" class="headerlink" title="C 中的 NULL 指针"></a>C 中的 NULL 指针</h2><p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为<strong>空</strong>指针。</p>
<p>NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  *ptr = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ptr 的地址是 %p\n&quot;</span>, ptr  );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ptr</span> 的地址是 <span class="number">0</span>x0</span><br></pre></td></tr></table></figure>

<p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</p>
<p>如需检查一个空指针，您可以使用 if 语句，如下所示：</p>
<p>if(ptr)     &#x2F;* 如果 p 非空，则完成 <em>&#x2F; if(!ptr)    &#x2F;</em> 如果 p 为空，则完成 *&#x2F;</p>
<h2 id="C-指针详解"><a href="#C-指针详解" class="headerlink" title="C 指针详解"></a>C 指针详解</h2><p>在 C 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C 程序员必须清楚的一些与指针相关的重要概念：</p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-pointer-arithmetic.html">指针的算术运算</a></td>
<td align="left">可以对指针进行四种算术运算：++、–、+、-</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-array-of-pointers.html">指针数组</a></td>
<td align="left">可以定义用来存储指针的数组。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-pointer-to-pointer.html">指向指针的指针</a></td>
<td align="left">C 允许指向指针的指针。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-passing-pointers-to-functions.html">传递指针给函数</a></td>
<td align="left">通过引用或地址传递参数，使传递的参数在调用函数中被改变。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/cprogramming/c-return-pointer-from-functions.html">从函数返回指针</a></td>
<td align="left">C 允许函数返回指针到局部变量、静态变量和动态内存分配。</td>
</tr>
</tbody></table>
<h1 id="C-指针的算术运算"><a href="#C-指针的算术运算" class="headerlink" title="C 指针的算术运算"></a>C 指针的算术运算</h1><p>C 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、–、+、-。</p>
<p>假设 <strong>ptr</strong> 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ptr</span>++</span><br></pre></td></tr></table></figure>

<p>在执行完上述的运算之后，<strong>ptr</strong> 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 <strong>ptr</strong> 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。</p>
<p>我们概括一下：</p>
<ul>
<li>指针的每一次递增，它其实会指向下一个元素的存储单元。</li>
<li>指针的每一次递减，它都会指向前一个元素的存储单元。</li>
<li>指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。</li>
</ul>
<h2 id="递增一个指针"><a href="#递增一个指针" class="headerlink" title="递增一个指针"></a>递增一个指针</h2><p>我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，数组可以看成一个指针常量。下面的程序递增变量指针，以便顺序访问数组中的每一个元素：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">   <span class="type">int</span>  i, *ptr;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 指针中的数组地址 */</span></span><br><span class="line">   ptr = var;</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;存储地址：var[%d] = %p\n&quot;</span>, i, ptr );</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;存储值：var[%d] = %d\n&quot;</span>, i, *ptr );</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* 指向下一个位置 */</span></span><br><span class="line">      ptr++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">存储地址：var[<span class="number">0</span>] = e4a298cc</span><br><span class="line">存储值：var[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">存储地址：var[<span class="number">1</span>] = e4a298d0</span><br><span class="line">存储值：var[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">存储地址：var[<span class="number">2</span>] = e4a298d4</span><br><span class="line">存储值：var[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure>

<h2 id="递减一个指针"><a href="#递减一个指针" class="headerlink" title="递减一个指针"></a>递减一个指针</h2><p>同样地，对指针进行递减运算，即把值减去其数据类型的字节数，如下所示：</p>
<p>实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">   <span class="type">int</span>  i, *ptr;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 指针中最后一个元素的地址 */</span></span><br><span class="line">   ptr = &amp;var[MAX<span class="number">-1</span>];</span><br><span class="line">   <span class="keyword">for</span> ( i = MAX; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">   &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;存储地址：var[%d] = %p\n&quot;</span>, i<span class="number">-1</span>, ptr );</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;存储值：var[%d] = %d\n&quot;</span>, i<span class="number">-1</span>, *ptr );</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* 指向下一个位置 */</span></span><br><span class="line">      ptr--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">存储地址：<span class="selector-tag">var</span><span class="selector-attr">[2]</span> = <span class="number">518</span>a0ae4</span><br><span class="line">存储值：<span class="selector-tag">var</span><span class="selector-attr">[2]</span> = <span class="number">200</span></span><br><span class="line">存储地址：<span class="selector-tag">var</span><span class="selector-attr">[1]</span> = <span class="number">518</span>a0ae0</span><br><span class="line">存储值：<span class="selector-tag">var</span><span class="selector-attr">[1]</span> = <span class="number">100</span></span><br><span class="line">存储地址：<span class="selector-tag">var</span><span class="selector-attr">[0]</span> = <span class="number">518</span>a0adc</span><br><span class="line">存储值：<span class="selector-tag">var</span><span class="selector-attr">[0]</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="指针的比较"><a href="#指针的比较" class="headerlink" title="指针的比较"></a>指针的比较</h2><p>指针可以用关系运算符进行比较，如 &#x3D;&#x3D;、&lt; 和 &gt;。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。</p>
<p>下面的程序修改了上面的实例，只要变量指针所指向的地址小于或等于数组的最后一个元素的地址 &amp;var[MAX - 1]，则把变量指针进行递增：</p>
<p>实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">   <span class="type">int</span>  i, *ptr;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 指针中第一个元素的地址 */</span></span><br><span class="line">   ptr = var;</span><br><span class="line">   i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> ( ptr &lt;= &amp;var[MAX - <span class="number">1</span>] )</span><br><span class="line">   &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;存储地址：var[%d] = %p\n&quot;</span>, i, ptr );</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;存储值：var[%d] = %d\n&quot;</span>, i, *ptr );</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* 指向上一个位置 */</span></span><br><span class="line">      ptr++;</span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">存储地址：<span class="selector-tag">var</span><span class="selector-attr">[0]</span> = <span class="number">0</span>x7ffeee2368cc</span><br><span class="line">存储值：<span class="selector-tag">var</span><span class="selector-attr">[0]</span> = <span class="number">10</span></span><br><span class="line">存储地址：<span class="selector-tag">var</span><span class="selector-attr">[1]</span> = <span class="number">0</span>x7ffeee2368d0</span><br><span class="line">存储值：<span class="selector-tag">var</span><span class="selector-attr">[1]</span> = <span class="number">100</span></span><br><span class="line">存储地址：<span class="selector-tag">var</span><span class="selector-attr">[2]</span> = <span class="number">0</span>x7ffeee2368d4</span><br><span class="line">存储值：<span class="selector-tag">var</span><span class="selector-attr">[2]</span> = <span class="number">200</span></span><br></pre></td></tr></table></figure>

<h1 id="C-指针数组"><a href="#C-指针数组" class="headerlink" title="C 指针数组"></a>C 指针数组</h1><p>在我们讲解指针数组的概念之前，先让我们来看一个实例，它用到了一个由 3 个整数组成的数组：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Value of var[%d] = %d\n&quot;</span>, i, var[i] );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Value of var[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">Value of var[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">Value of var[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>可能有一种情况，我们想要让数组存储指向 int 或 char 或其他数据类型的指针。下面是一个指向整数的指针数组的声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ptr[MAX];</span><br></pre></td></tr></table></figure>

<p>在这里，把 <strong>ptr</strong> 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。下面的实例用到了三个整数，它们将存储在一个指针数组中，如下所示：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">   <span class="type">int</span> i, *ptr[MAX];</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      ptr[i] = &amp;var[i]; <span class="comment">/* 赋值为整数的地址 */</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Value of var[%d] = %d\n&quot;</span>, i, *ptr[i] );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Value</span> of var[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"><span class="attribute">Value</span> of var[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line"><span class="attribute">Value</span> of var[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>您也可以用一个指向字符的指针数组来存储一个字符串列表，如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> *names[] = &#123;</span><br><span class="line">                   <span class="string">&quot;Zara Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Hina Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Nuha Ali&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Sara Ali&quot;</span>,</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Value of names[%d] = %s\n&quot;</span>, i, names[i] );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Value of names[<span class="number">0</span>] <span class="operator">=</span> Zara Ali</span><br><span class="line">Value of names[<span class="number">1</span>] <span class="operator">=</span> Hina Ali</span><br><span class="line">Value of names[<span class="number">2</span>] <span class="operator">=</span> Nuha Ali</span><br><span class="line">Value of names[<span class="number">3</span>] <span class="operator">=</span> Sara Ali</span><br></pre></td></tr></table></figure>

<h2 id="指针与数组的等价性"><a href="#指针与数组的等价性" class="headerlink" title="指针与数组的等价性"></a>指针与数组的等价性</h2><ul>
<li>一个一维数组和一个指针等价，都代表地址，都可以访问数组中的所有元素；<code>int a[10] </code>与指针 <code>int *pa</code></li>
<li>一个而我数组，可以看成是一个一维数组，每个元素又是一个一维数组；<code>int a[3][4]</code>与<code>int a[3] = &#123;a[0],a[1],a[2]&#125;</code></li>
<li>一个指针数组，指向二维数组的每一行，指针数组的数组元素是指针，所以指向指针数组的指针就是指针的指针。即可以使用”指针的指针“指向指针数组。<code>int *pa[3],int a[3][4]与int **p</code></li>
</ul>
<h1 id="C-指向指针的指针"><a href="#C-指向指针的指针" class="headerlink" title="C 指向指针的指针"></a>C 指向指针的指针</h1><p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/09/pointer_to_pointer.jpg" alt="C 中指向指针的指针"></p>
<p>一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> **<span class="built_in">var</span>;</span><br></pre></td></tr></table></figure>

<p>当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，如下面实例所示：</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/09/c-pointerxxxxx.png" alt="img"></p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  V;</span><br><span class="line">   <span class="type">int</span>  *Pt1;</span><br><span class="line">   <span class="type">int</span>  **Pt2;</span><br><span class="line"> </span><br><span class="line">   V = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 获取 V 的地址 */</span></span><br><span class="line">   Pt1 = &amp;V;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用运算符 &amp; 获取 Pt1 的地址 */</span></span><br><span class="line">   Pt2 = &amp;Pt1;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用 pptr 获取值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;var = %d\n&quot;</span>, V );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Pt1 = %p\n&quot;</span>, Pt1 );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;*Pt1 = %d\n&quot;</span>, *Pt1 );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pt2 = %p\n&quot;</span>, Pt2 );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;**Pt2 = %d\n&quot;</span>, **Pt2);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var</span> <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"><span class="attribute">Pt1</span> <span class="operator">=</span> <span class="number">0</span>x7ffee2d5e8d8</span><br><span class="line">*Pt1 <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"><span class="attribute">Pt2</span> <span class="operator">=</span> <span class="number">0</span>x7ffee2d5e8d0</span><br><span class="line">**Pt2 <span class="operator">=</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h1 id="C-传递指针给函数"><a href="#C-传递指针给函数" class="headerlink" title="C 传递指针给函数"></a>C 传递指针给函数</h1><p>C 语言允许您传递指针给函数，只需要简单地声明函数参数为指针类型即可。</p>
<p>下面的实例中，我们传递一个无符号的 long 型指针给函数，并在函数内改变这个值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">getSeconds</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *par)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> sec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   getSeconds( &amp;sec );</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 输出实际值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Number of seconds: %ld\n&quot;</span>, sec );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getSeconds</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *par)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 获取当前的秒数 */</span></span><br><span class="line">   *par = time( <span class="literal">NULL</span> );</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Number</span> of seconds :<span class="number">1294450468</span></span><br></pre></td></tr></table></figure>

<p>能接受指针作为参数的函数，也能接受数组作为参数，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">getAverage</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> size)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 带有 5 个元素的整型数组  */</span></span><br><span class="line">   <span class="type">int</span> balance[<span class="number">5</span>] = &#123;<span class="number">1000</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">50</span>&#125;;</span><br><span class="line">   <span class="type">double</span> avg;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 传递一个指向数组的指针作为参数 */</span></span><br><span class="line">   avg = getAverage( balance, <span class="number">5</span> ) ;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出返回值  */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Average value is: %f\n&quot;</span>, avg );</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">getAverage</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>    i, sum = <span class="number">0</span>;      </span><br><span class="line">  <span class="type">double</span> avg;          </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    sum += arr[i];</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  avg = (<span class="type">double</span>)sum / size;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> avg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Average value is: <span class="number">214.40000</span></span><br></pre></td></tr></table></figure>

<h1 id="C-从函数返回指针"><a href="#C-从函数返回指针" class="headerlink" title="C 从函数返回指针"></a>C 从函数返回指针</h1><p>在上一章中，我们已经了解了 C 语言中如何从函数返回数组，类似地，C 允许您从函数返回指针。为了做到这点，您必须声明一个返回指针的函数，如下所示：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">int * myFunction()</span><br><span class="line">&#123;</span><br><span class="line"><span class="bullet">.</span></span><br><span class="line"><span class="bullet"></span><span class="bullet">.</span></span><br><span class="line"><span class="bullet"></span><span class="bullet">.</span></span><br><span class="line"><span class="bullet"></span>&#125;</span><br></pre></td></tr></table></figure>

<p>另外，C 语言不支持在调用函数时返回局部变量的地址，除非定义局部变量为 <strong>static</strong> 变量。</p>
<p>现在，让我们来看下面的函数，它会生成 10 个随机数，并使用表示指针的数组名（即第一个数组元素的地址）来返回它们，具体如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 要生成和返回随机数的函数 */</span></span><br><span class="line"><span class="type">int</span> * <span class="title function_">getRandom</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span>  r[<span class="number">10</span>];</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 设置种子 */</span></span><br><span class="line">   srand( (<span class="type">unsigned</span>)time( <span class="literal">NULL</span> ) );</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">   &#123;</span><br><span class="line">      r[i] = rand();</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r[i] );</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 要调用上面定义函数的主函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 一个指向整数的指针 */</span></span><br><span class="line">   <span class="type">int</span> *p;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">   p = getRandom();</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;*(p + [%d]) : %d\n&quot;</span>, i, *(p + i) );</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1523198053</span></span><br><span class="line"><span class="number">1187214107</span></span><br><span class="line"><span class="number">1108300978</span></span><br><span class="line"><span class="number">430494959</span></span><br><span class="line"><span class="number">1421301276</span></span><br><span class="line"><span class="number">930971084</span></span><br><span class="line"><span class="number">123250484</span></span><br><span class="line"><span class="number">106932140</span></span><br><span class="line"><span class="number">1604461820</span></span><br><span class="line"><span class="number">149169022</span></span><br><span class="line">*(p + [<span class="number">0</span>]) : <span class="number">1523198053</span></span><br><span class="line">*(p + [<span class="number">1</span>]) : <span class="number">1187214107</span></span><br><span class="line">*(p + [<span class="number">2</span>]) : <span class="number">1108300978</span></span><br><span class="line">*(p + [<span class="number">3</span>]) : <span class="number">430494959</span></span><br><span class="line">*(p + [<span class="number">4</span>]) : <span class="number">1421301276</span></span><br><span class="line">*(p + [<span class="number">5</span>]) : <span class="number">930971084</span></span><br><span class="line">*(p + [<span class="number">6</span>]) : <span class="number">123250484</span></span><br><span class="line">*(p + [<span class="number">7</span>]) : <span class="number">106932140</span></span><br><span class="line">*(p + [<span class="number">8</span>]) : <span class="number">1604461820</span></span><br><span class="line">*(p + [<span class="number">9</span>]) : <span class="number">149169022</span></span><br></pre></td></tr></table></figure>

<h1 id="函数指针与回调函数"><a href="#函数指针与回调函数" class="headerlink" title="函数指针与回调函数"></a>函数指针与回调函数</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是指向函数的指针变量。</p>
<p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。</p>
<p>函数指针可以像一般函数一样，用于调用函数、传递参数。</p>
<p>函数指针变量的声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*fun_ptr)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>; <span class="comment">// 声明一个指向同样参数、返回值的函数指针类型</span></span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<p>以下实例声明了函数指针变量 p，指向函数 max：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* p 是函数指针 */</span></span><br><span class="line">    <span class="type">int</span> (* p)(<span class="type">int</span>, <span class="type">int</span>) = &amp; max; <span class="comment">// &amp;可以省略</span></span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入三个数字:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp; a, &amp; b, &amp; c);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class="line">    d = p(p(a, b), c); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大的数字是: %d\n&quot;</span>, d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行，输出结果如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">请输入三个数字:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">最大的数字是: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><h3 id="函数指针作为某个函数的参数"><a href="#函数指针作为某个函数的参数" class="headerlink" title="函数指针作为某个函数的参数"></a>函数指针作为某个函数的参数</h3><p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p>
<p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p>
<blockquote>
<p>以下是来自知乎作者常溪玲的解说：</p>
<p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p>
</blockquote>
<p><strong>实例</strong></p>
<p>实例中 <strong>populate_array()</strong> 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。</p>
<p>实例中我们定义了回调函数 **getNextRandomValue()**，它返回一个随机值，它作为一个函数指针传递给 <strong>populate_array()</strong> 函数。</p>
<p><strong>populate_array()</strong> 将调用 <strong>10</strong> 次回调函数，并将回调函数的返回值赋值给数组。</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">populate_array</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">size_t</span> arraySize, <span class="type">int</span> (*getNextValue)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;arraySize; i++)</span><br><span class="line">        <span class="built_in">array</span>[i] = getNextValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取随机值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getNextRandomValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rand();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> myarray[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">/* getNextRandomValue 不能加括号，否则无法编译，因为加上括号之后相当于传入此参数时传入了 int , 而不是函数指针*/</span></span><br><span class="line">    populate_array(myarray, <span class="number">10</span>, getNextRandomValue);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, myarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编译执行，输出结果如下：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">16807 </span><span class="number">282475249</span> <span class="number">1622650073</span> <span class="number">984943658</span> <span class="number">1144108930</span> <span class="number">470211272</span> <span class="number">101027544</span> <span class="number">1457850878</span> <span class="number">1458777923</span> <span class="number">2007237709</span> </span><br></pre></td></tr></table></figure>

<h1 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C 字符串"></a>C 字符串</h1><p>在 C 语言中，字符串实际上是使用空字符 <strong>\0</strong> 结尾的一维字符数组。因此，<strong>\0</strong> 是用于标记字符串的结束。</p>
<p><strong>空字符（Null character</strong>）又称结束符，缩写 <strong>NUL</strong>，是一个数值为 <strong>0</strong> 的控制字符，<strong>\0</strong> 是转义字符，意思是告诉编译器，这不是字符 <strong>0</strong>，而是空字符。</p>
<p>下面的声明和初始化创建了一个 <strong>RUNOOB</strong> 字符串。由于在数组的末尾存储了空字符 <strong>\0</strong>，所以字符数组的大小比单词 <strong>RUNOOB</strong> 的字符数多一个。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">char site[] <span class="operator">=</span> <span class="string">&quot;RUNOOB&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>以下是 C&#x2F;C++ 中定义的字符串的内存表示：</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/09/c-strings-2020-12-21.png" alt="C/C++ 中的字符串表示"></p>
<p>其实，您不需要把 <strong>null</strong> 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 <strong>\0</strong> 放在字符串的末尾。让我们尝试输出上面的字符串：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;菜鸟教程: %s\n&quot;</span>, site );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">菜鸟教程: RUNOOB</span></span><br></pre></td></tr></table></figure>

<p>C 中有大量操作字符串的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 目的</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
</tr>
</tbody></table>
<p>下面的实例使用了上述的一些函数：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> str1[<span class="number">14</span>] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line">   <span class="type">char</span> str2[<span class="number">14</span>] = <span class="string">&quot;google&quot;</span>;</span><br><span class="line">   <span class="type">char</span> str3[<span class="number">14</span>];</span><br><span class="line">   <span class="type">int</span>  len ;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 复制 str1 到 str3 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>(str3, str1);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;strcpy( str3, str1) :  %s\n&quot;</span>, str3 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 连接 str1 和 str2 */</span></span><br><span class="line">   <span class="built_in">strcat</span>( str1, str2);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;strcat( str1, str2):   %s\n&quot;</span>, str1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 连接后，str1 的总长度 */</span></span><br><span class="line">   len = <span class="built_in">strlen</span>(str1);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;strlen(str1) :  %d\n&quot;</span>, len );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">strcpy</span><span class="params">( str3, str1)</span></span> :  runoob</span><br><span class="line"><span class="function"><span class="title">strcat</span><span class="params">( str1, str2)</span></span>:   runoobgoogle</span><br><span class="line"><span class="function"><span class="title">strlen</span><span class="params">(str1)</span></span> :  <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>您可以在 C 标准库中找到更多字符串相关的函数。</p>
<h1 id="C-结构体"><a href="#C-结构体" class="headerlink" title="C 结构体"></a>C 结构体</h1><p>C 数组允许定义可存储相同类型数据项的变量，<strong>结构</strong>是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
<p>结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：</p>
<ul>
<li>Title</li>
<li>Author</li>
<li>Subject</li>
<li>Book ID</li>
</ul>
<h2 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h2><p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> &#123;</span> </span><br><span class="line">    member-<span class="built_in">list</span></span><br><span class="line">    member-<span class="built_in">list</span> </span><br><span class="line">    member-<span class="built_in">list</span>  </span><br><span class="line">    ...</span><br><span class="line">&#125; variable-<span class="built_in">list</span> ;</span><br></pre></td></tr></table></figure>

<p><strong>tag</strong> 是结构体标签。</p>
<p><strong>member-list</strong> 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。</p>
<p><strong>variable-list</strong> 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125; book;</span><br></pre></td></tr></table></figure>

<p>在一般情况下，<strong>tag、member-list、variable-list</strong> 这 3 部分至少要出现 2 个。以下为实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//同时又声明了结构体变量s1</span></span><br><span class="line"><span class="comment">//这个结构体并没有标明其标签</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">&#125; s1;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//结构体的标签被命名为SIMPLE,没有声明变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">t1</span>, <span class="title">t2</span>[20], *<span class="title">t3</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//也可以用typedef创建新类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">double</span> c; </span><br><span class="line">&#125; Simple2;</span><br><span class="line"><span class="comment">//现在可以用Simple2作为类型声明新的结构体变量</span></span><br><span class="line">Simple2 u1, u2[<span class="number">20</span>], *u3;</span><br></pre></td></tr></table></figure>



<p>在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3&#x3D;&amp;s1，则是非法的。</p>
<p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此结构体的声明包含了其他的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">COMPLEX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">a</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//此结构体的声明包含了指向自己类型的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">next_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span>    <span class="comment">//对结构体B进行不完整声明</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//结构体A中包含指向结构体B的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="结构体变量的初始化"><a href="#结构体变量的初始化" class="headerlink" title="结构体变量的初始化"></a>结构体变量的初始化</h2><p>和其它类型变量一样，对结构体变量可以在定义时指定初始值。</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125; book = &#123;<span class="string">&quot;C 语言&quot;</span>, <span class="string">&quot;RUNOOB&quot;</span>, <span class="string">&quot;编程语言&quot;</span>, <span class="number">123456</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n&quot;</span>, book.title, book.author, book.subject, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行输出结果为：</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">title</span><span class="punctuation"> :</span> <span class="string">C 语言</span></span><br><span class="line"><span class="attribute">author</span><span class="punctuation">:</span> <span class="string">RUNOOB</span></span><br><span class="line"><span class="attribute">subject</span><span class="punctuation">:</span> <span class="string">编程语言</span></span><br><span class="line"><span class="attribute">book_id</span><span class="punctuation">:</span> <span class="string">123456</span></span><br></pre></td></tr></table></figure>

<h2 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h2><p>为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 <strong>struct</strong> 关键字来定义结构类型的变量。下面的实例演示了结构的用法：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book1</span>;</span>        <span class="comment">/* 声明 Book1，类型为 Books */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book2</span>;</span>        <span class="comment">/* 声明 Book2，类型为 Books */</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book1 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.author, <span class="string">&quot;Nuha Ali&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">&quot;C Programming Tutorial&quot;</span>);</span><br><span class="line">   Book1.book_id = <span class="number">6495407</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book2 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">&quot;Telecom Billing&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.author, <span class="string">&quot;Zara Ali&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">&quot;Telecom Billing Tutorial&quot;</span>);</span><br><span class="line">   Book2.book_id = <span class="number">6495700</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出 Book1 信息 */</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 1 title : %s\n&quot;</span>, Book1.title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 1 author : %s\n&quot;</span>, Book1.author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 1 subject : %s\n&quot;</span>, Book1.subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 1 book_id : %d\n&quot;</span>, Book1.book_id);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出 Book2 信息 */</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 2 title : %s\n&quot;</span>, Book2.title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 2 author : %s\n&quot;</span>, Book2.author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 2 subject : %s\n&quot;</span>, Book2.subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book 2 book_id : %d\n&quot;</span>, Book2.book_id);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Book </span><span class="number">1</span> title : C Programming</span><br><span class="line"><span class="keyword">Book </span><span class="number">1</span> author : Nuha Ali</span><br><span class="line"><span class="keyword">Book </span><span class="number">1</span> <span class="keyword">subject </span>: C Programming Tutorial</span><br><span class="line"><span class="keyword">Book </span><span class="number">1</span> <span class="keyword">book_id </span>: <span class="number">6495407</span></span><br><span class="line"><span class="keyword">Book </span><span class="number">2</span> title : Telecom <span class="keyword">Billing</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">Book </span><span class="number">2</span> author : Zara Ali</span><br><span class="line"><span class="keyword">Book </span><span class="number">2</span> <span class="keyword">subject </span>: Telecom <span class="keyword">Billing </span>Tutorial</span><br><span class="line"><span class="keyword">Book </span><span class="number">2</span> <span class="keyword">book_id </span>: <span class="number">6495700</span></span><br></pre></td></tr></table></figure>

<h2 id="结构作为函数参数"><a href="#结构作为函数参数" class="headerlink" title="结构作为函数参数"></a>结构作为函数参数</h2><p>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printBook</span><span class="params">( <span class="keyword">struct</span> Books book )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book1</span>;</span>        <span class="comment">/* 声明 Book1，类型为 Books */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book2</span>;</span>        <span class="comment">/* 声明 Book2，类型为 Books */</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book1 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.author, <span class="string">&quot;Nuha Ali&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">&quot;C Programming Tutorial&quot;</span>);</span><br><span class="line">   Book1.book_id = <span class="number">6495407</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book2 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">&quot;Telecom Billing&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.author, <span class="string">&quot;Zara Ali&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">&quot;Telecom Billing Tutorial&quot;</span>);</span><br><span class="line">   Book2.book_id = <span class="number">6495700</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出 Book1 信息 */</span></span><br><span class="line">   printBook( Book1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出 Book2 信息 */</span></span><br><span class="line">   printBook( Book2 );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printBook</span><span class="params">( <span class="keyword">struct</span> Books book )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book author : %s\n&quot;</span>, book.author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book subject : %s\n&quot;</span>, book.subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Book title : C Programming</span><br><span class="line">Book author : Nuha Ali</span><br><span class="line">Book subject : C Programming Tutorial</span><br><span class="line">Book book_id : <span class="number">6495407</span></span><br><span class="line">Book title : Telecom Billing</span><br><span class="line">Book author : Zara Ali</span><br><span class="line">Book subject : Telecom Billing Tutorial</span><br><span class="line">Book book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure>

<h2 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h2><p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span> *<span class="title">struct_pointer</span>;</span></span><br></pre></td></tr></table></figure>

<p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure>

<p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure>

<p>让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printBook</span><span class="params">( <span class="keyword">struct</span> Books *book )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book1</span>;</span>        <span class="comment">/* 声明 Book1，类型为 Books */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book2</span>;</span>        <span class="comment">/* 声明 Book2，类型为 Books */</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book1 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.author, <span class="string">&quot;Nuha Ali&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">&quot;C Programming Tutorial&quot;</span>);</span><br><span class="line">   Book1.book_id = <span class="number">6495407</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book2 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">&quot;Telecom Billing&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.author, <span class="string">&quot;Zara Ali&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">&quot;Telecom Billing Tutorial&quot;</span>);</span><br><span class="line">   Book2.book_id = <span class="number">6495700</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 通过传 Book1 的地址来输出 Book1 信息 */</span></span><br><span class="line">   printBook( &amp;Book1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 通过传 Book2 的地址来输出 Book2 信息 */</span></span><br><span class="line">   printBook( &amp;Book2 );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printBook</span><span class="params">( <span class="keyword">struct</span> Books *book )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book title : %s\n&quot;</span>, book-&gt;title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book author : %s\n&quot;</span>, book-&gt;author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book subject : %s\n&quot;</span>, book-&gt;subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book-&gt;book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Book </span>title : C Programming</span><br><span class="line"><span class="keyword">Book </span>author : Nuha Ali</span><br><span class="line"><span class="keyword">Book </span><span class="keyword">subject </span>: C Programming Tutorial</span><br><span class="line"><span class="keyword">Book </span><span class="keyword">book_id </span>: <span class="number">6495407</span></span><br><span class="line"><span class="keyword">Book </span>title : Telecom <span class="keyword">Billing</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">Book </span>author : Zara Ali</span><br><span class="line"><span class="keyword">Book </span><span class="keyword">subject </span>: Telecom <span class="keyword">Billing </span>Tutorial</span><br><span class="line"><span class="keyword">Book </span><span class="keyword">book_id </span>: <span class="number">6495700</span></span><br></pre></td></tr></table></figure>

<h1 id="C-共用体"><a href="#C-共用体" class="headerlink" title="C 共用体"></a>C 共用体</h1><p><strong>共用体</strong>是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</p>
<h2 id="定义共用体"><a href="#定义共用体" class="headerlink" title="定义共用体"></a>定义共用体</h2><p>为了定义共用体，您必须使用 <strong>union</strong> 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> [<span class="title">union</span> <span class="title">tag</span>]</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125; [one or more <span class="class"><span class="keyword">union</span> <span class="title">variables</span>];</span></span><br></pre></td></tr></table></figure>

<p><strong>union tag</strong> 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">float</span> f;</span><br><span class="line">   <span class="type">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125; data;</span><br></pre></td></tr></table></figure>

<p>现在，<strong>Data</strong> 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。</p>
<p><strong>共用体占用的内存应足够存储共用体中最大的成员</strong>。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。下面的实例将显示上面的共用体占用的总内存大小：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">float</span> f;</span><br><span class="line">   <span class="type">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span>        </span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Memory size occupied by data : %d\n&quot;</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Memory <span class="built_in">size</span> occupied by <span class="keyword">data</span> : <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h2 id="访问共用体成员"><a href="#访问共用体成员" class="headerlink" title="访问共用体成员"></a>访问共用体成员</h2><p>为了访问共用体的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 <strong>union</strong> 关键字来定义共用体类型的变量。下面的实例演示了共用体的用法：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">float</span> f;</span><br><span class="line">   <span class="type">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span>        </span><br><span class="line"> </span><br><span class="line">   data.i = <span class="number">10</span>;</span><br><span class="line">   data.f = <span class="number">220.5</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>( data.str, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.i : %d\n&quot;</span>, data.i);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.f : %f\n&quot;</span>, data.f);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.str : %s\n&quot;</span>, data.str);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">data.i : <span class="number">1917853763</span></span><br><span class="line">data.f : <span class="number">4122360580327794860452759994368.000000</span></span><br><span class="line">data.str : C Programming</span><br></pre></td></tr></table></figure>

<p>在这里，我们可以看到共用体的 <strong>i</strong> 和 <strong>f</strong> 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 <strong>str</strong> 成员能够完好输出的原因。现在让我们再来看一个相同的实例，这次我们在同一时间只使用一个变量，这也演示了使用共用体的主要目的：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">float</span> f;</span><br><span class="line">   <span class="type">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span>        </span><br><span class="line"> </span><br><span class="line">   data.i = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.i : %d\n&quot;</span>, data.i);</span><br><span class="line">   </span><br><span class="line">   data.f = <span class="number">220.5</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.f : %f\n&quot;</span>, data.f);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">strcpy</span>( data.str, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.str : %s\n&quot;</span>, data.str);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span>.i : 10</span></span><br><span class="line"><span class="class"><span class="keyword">data</span>.f : 220.500000</span></span><br><span class="line"><span class="class"><span class="keyword">data</span>.str : <span class="type">C</span> <span class="type">Programming</span></span></span><br></pre></td></tr></table></figure>

<p>在这里，所有的成员都能完好输出，因为同一时间只用到一个成员。</p>
<p>总结：共用体同一时间只能使用一个成员，只保留最后一个使用的成员。</p>
<h1 id="C-位域"><a href="#C-位域" class="headerlink" title="C 位域"></a>C 位域</h1><p>如果程序的结构中包含多个开关量，只有 <strong>TRUE&#x2F;FALSE</strong> 变量，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> widthValidated;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> heightValidated;</span><br><span class="line">&#125; status;</span><br></pre></td></tr></table></figure>

<p>这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1。在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。例如，上面的结构可以重写成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> widthValidated : <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> heightValidated : <span class="number">1</span>;</span><br><span class="line">&#125; status;</span><br></pre></td></tr></table></figure>

<p>现在，上面的结构中，status 变量将占用 4 个字节的内存空间，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 status 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。让我们看看下面的实例来理解这个概念：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 定义简单的结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> widthValidated;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> heightValidated;</span><br><span class="line">&#125; status1;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 定义位域结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> widthValidated : <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> heightValidated : <span class="number">1</span>;</span><br><span class="line">&#125; status2;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Memory size occupied by status1 : %d\n&quot;</span>, <span class="keyword">sizeof</span>(status1));</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Memory size occupied by status2 : %d\n&quot;</span>, <span class="keyword">sizeof</span>(status2));</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Memory</span> size occupied <span class="keyword">by</span> status1 : 8</span><br><span class="line"><span class="keyword">Memory</span> size occupied <span class="keyword">by</span> status2 : 4</span><br></pre></td></tr></table></figure>

<h2 id="位域声明"><a href="#位域声明" class="headerlink" title="位域声明"></a>位域声明</h2><p>有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为”位域”或”位段”。</p>
<p>所谓”位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>
<p>典型的实例：</p>
<ul>
<li>用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。</li>
<li>读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。</li>
</ul>
<h3 id="位域的定义和位域变量的说明"><a href="#位域的定义和位域变量的说明" class="headerlink" title="位域的定义和位域变量的说明"></a>位域的定义和位域变量的说明</h3><p>位域定义与结构定义相仿，其形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 位域结构名 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"> 位域列表</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中位域列表的形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type [member_name] : width ;</span><br></pre></td></tr></table></figure>

<p>下面是有关位域中变量元素的描述：</p>
<table>
<thead>
<tr>
<th align="left">元素</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">type</td>
<td align="left">只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。</td>
</tr>
<tr>
<td align="left">member_name</td>
<td align="left">位域的名称。</td>
</tr>
<tr>
<td align="left">width</td>
<td align="left">位域中位的数量。宽度必须小于或等于指定类型的位宽度。</td>
</tr>
</tbody></table>
<p>带有预定义宽度的变量被称为<strong>位域</strong>。位域可以存储多于 1 位的数，例如，需要一个变量来存储从 0 到 7 的值，您可以定义一个宽度为 3 位的位域，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> age : <span class="number">3</span>;</span><br><span class="line">&#125; Age;</span><br></pre></td></tr></table></figure>



<p>上面的结构定义指示 C 编译器，age 变量将只使用 3 位来存储这个值，如果您试图使用超过 3 位，则无法完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a:<span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> b:<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c:<span class="number">6</span>;</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure>

<p>data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。</p>
<p>让我们再来看一个实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packed_struct</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f1:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f2:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f3:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f4:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> type:<span class="number">4</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> my_int:<span class="number">9</span>;</span><br><span class="line">&#125; pack;</span><br></pre></td></tr></table></figure>

<p>在这里，packed_struct 包含了 6 个成员：四个 1 位的标识符 f1..f4、一个 4 位的 type 和一个 9 位的 my_int。</p>
<p>让我们来看下面的实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> age : <span class="number">3</span>;</span><br><span class="line">&#125; Age;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   Age.age = <span class="number">4</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Sizeof( Age ) : %d\n&quot;</span>, <span class="keyword">sizeof</span>(Age) );</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Age.age : %d\n&quot;</span>, Age.age );</span><br><span class="line"> </span><br><span class="line">   Age.age = <span class="number">7</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Age.age : %d\n&quot;</span>, Age.age );</span><br><span class="line"> </span><br><span class="line">   Age.age = <span class="number">8</span>; <span class="comment">// 二进制表示为 1000 有四位，超出</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Age.age : %d\n&quot;</span>, Age.age );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译时，它会带有警告，当上面的代码被执行时，它会产生下列结果：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Sizeof</span><span class="params">( Age )</span></span> : <span class="number">4</span></span><br><span class="line">Age<span class="selector-class">.age</span> : <span class="number">4</span></span><br><span class="line">Age<span class="selector-class">.age</span> : <span class="number">7</span></span><br><span class="line">Age<span class="selector-class">.age</span> : <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>对于位域的定义尚有以下几点说明：</strong></p>
<ul>
<li><p>一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> a:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span>  :<span class="number">4</span>;    <span class="comment">/* 空域 */</span></span><br><span class="line">    <span class="type">unsigned</span> b:<span class="number">4</span>;    <span class="comment">/* 从下一单元开始存放 */</span></span><br><span class="line">    <span class="type">unsigned</span> c:<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。</p>
</li>
<li><p>位域的宽度不能超过它所依附的数据类型的长度，成员变量都是有类型的，这个类型限制了成员变量的最大长度，**:** 后面的数字不能超过这个长度。</p>
</li>
<li><p>位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a:<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>  :<span class="number">2</span>;    <span class="comment">/* 该 2 位不能使用 */</span></span><br><span class="line">    <span class="type">int</span> b:<span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> c:<span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。</p>
<h3 id="位域的使用"><a href="#位域的使用" class="headerlink" title="位域的使用"></a>位域的使用</h3><p>位域的使用和结构成员的使用相同，其一般形式为：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">位域变量名.位域名</span><br><span class="line">位域变量名-&gt;位域名</span><br></pre></td></tr></table></figure>

<p>位域允许用各种格式输出。</p>
<p>请看下面的实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> a:<span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> b:<span class="number">3</span>;</span><br><span class="line">        <span class="type">unsigned</span> c:<span class="number">4</span>;</span><br><span class="line">    &#125; bit,*pbit;</span><br><span class="line">    bit.a=<span class="number">1</span>;    <span class="comment">/* 给位域赋值（应注意赋值不能超过该位域的允许范围） */</span></span><br><span class="line">    bit.b=<span class="number">7</span>;    <span class="comment">/* 给位域赋值（应注意赋值不能超过该位域的允许范围） */</span></span><br><span class="line">    bit.c=<span class="number">15</span>;    <span class="comment">/* 给位域赋值（应注意赋值不能超过该位域的允许范围） */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,bit.a,bit.b,bit.c);    <span class="comment">/* 以整型量格式输出三个域的内容 */</span></span><br><span class="line">    pbit=&amp;bit;    <span class="comment">/* 把位域变量 bit 的地址送给指针变量 pbit */</span></span><br><span class="line">    pbit-&gt;a=<span class="number">0</span>;    <span class="comment">/* 用指针方式给位域 a 重新赋值，赋为 0 */</span></span><br><span class="line">    pbit-&gt;b&amp;=<span class="number">3</span>;    <span class="comment">/* 使用了复合的位运算符 &quot;&amp;=&quot;，相当于：pbit-&gt;b=pbit-&gt;b&amp;3，位域 b 中原有值为 7，与 3 作按位与运算的结果为 3（111&amp;011=011，十进制值为 3） */</span></span><br><span class="line">    pbit-&gt;c|=<span class="number">1</span>;    <span class="comment">/* 使用了复合位运算符&quot;|=&quot;，相当于：pbit-&gt;c=pbit-&gt;c|1，其结果为 15 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,pbit-&gt;a,pbit-&gt;b,pbit-&gt;c);    <span class="comment">/* 用指针方式输出了这三个域的值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例程序中定义了位域结构 bs，三个位域为 a、b、c。说明了 bs 类型的变量 bit 和指向 bs 类型的指针变量 pbit。这表示位域也是可以使用指针的。</p>
<h1 id="C-typedef"><a href="#C-typedef" class="headerlink" title="C typedef"></a>C typedef</h1><p>C 语言提供了 <strong>typedef</strong> 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 <strong>BYTE</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> BYTE;</span><br></pre></td></tr></table></figure>

<p>在这个类型定义之后，标识符 BYTE 可作为类型 <strong>unsigned char</strong> 的缩写，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BYTE  b1, b2;</span><br></pre></td></tr></table></figure>

<p>按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> byte;</span><br></pre></td></tr></table></figure>

<p>您也可以使用 <strong>typedef</strong> 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125; Book;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   Book book;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">strcpy</span>( book.title, <span class="string">&quot;C 教程&quot;</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( book.author, <span class="string">&quot;Runoob&quot;</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( book.subject, <span class="string">&quot;编程语言&quot;</span>);</span><br><span class="line">   book.book_id = <span class="number">12345</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;书标题 : %s\n&quot;</span>, book.title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;书作者 : %s\n&quot;</span>, book.author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;书类目 : %s\n&quot;</span>, book.subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;书 ID : %d\n&quot;</span>, book.book_id);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">书标题 : C 教程</span><br><span class="line">书作者 : Runoob</span><br><span class="line">书类目 : 编程语言</span><br><span class="line">书 ID : <span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h2 id="typedef-vs-define"><a href="#typedef-vs-define" class="headerlink" title="typedef vs #define"></a>typedef vs #define</h2><p><strong>#define</strong> 是 C 指令，用于为各种数据类型定义别名，与 <strong>typedef</strong> 类似，但是它们有以下几点不同：</p>
<ul>
<li><strong>typedef</strong> 仅限于为类型定义符号名称，**#define** 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。</li>
<li><strong>typedef</strong> 是由编译器执行解释的，**#define** 语句是由预编译器进行处理的。</li>
</ul>
<p>下面是 #define 的最简单的用法：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;TRUE 的值: %d\n&quot;</span>, TRUE);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;FALSE 的值: %d\n&quot;</span>, FALSE);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="literal">TRUE</span> 的值: <span class="number">1</span></span><br><span class="line"><span class="literal">FALSE</span> 的值: <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h1 id="C-输入-amp-输出"><a href="#C-输入-amp-输出" class="headerlink" title="C 输入 &amp; 输出"></a>C 输入 &amp; 输出</h1><p>当我们提到<strong>输入</strong>时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。C 语言提供了一系列内置的函数来读取给定的输入，并根据需要填充到程序中。</p>
<p>当我们提到<strong>输出</strong>时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。C 语言提供了一系列内置的函数来输出数据到计算机屏幕上和保存数据到文本文件或二进制文件中。</p>
<h2 id="标准文件"><a href="#标准文件" class="headerlink" title="标准文件"></a>标准文件</h2><p>C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。</p>
<table>
<thead>
<tr>
<th align="left">标准文件</th>
<th align="left">文件指针</th>
<th align="left">设备</th>
</tr>
</thead>
<tbody><tr>
<td align="left">标准输入</td>
<td align="left">stdin</td>
<td align="left">键盘</td>
</tr>
<tr>
<td align="left">标准输出</td>
<td align="left">stdout</td>
<td align="left">屏幕</td>
</tr>
<tr>
<td align="left">标准错误</td>
<td align="left">stderr</td>
<td align="left">您的屏幕</td>
</tr>
</tbody></table>
<p>文件指针是访问文件的方式，本节将讲解如何从键盘上读取值以及如何把结果输出到屏幕上。</p>
<p>C 语言中的 I&#x2F;O (输入&#x2F;输出) 通常使用 printf() 和 scanf() 两个函数。</p>
<p>scanf() 函数用于从标准输入（键盘）读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）。</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>      <span class="comment">// 执行 printf() 函数需要该库</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;菜鸟教程&quot;</span>);  <span class="comment">//显示引号中的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编译以上程序，输出结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">菜鸟教程</span><br></pre></td></tr></table></figure>

<p><strong>实例解析：</strong></p>
<ul>
<li>所有的 C 语言程序都需要包含 <strong>main()</strong> 函数。 代码从 <strong>main()</strong> 函数开始执行。</li>
<li><strong>printf()</strong> 用于格式化输出到屏幕。<strong>printf()</strong> 函数在 <strong>“stdio.h”</strong> 头文件中声明。</li>
<li><strong>stdio.h</strong> 是一个头文件 (标准输入输出头文件) and <strong>#include</strong> 是一个预处理命令，用来引入头文件。 当编译器遇到 <strong>printf()</strong> 函数时，如果没有找到 <strong>stdio.h</strong> 头文件，会发生编译错误。</li>
<li><strong>return 0;</strong> 语句用于表示退出程序。</li>
</ul>
<h2 id="d-格式化输出整数"><a href="#d-格式化输出整数" class="headerlink" title="%d 格式化输出整数"></a>%d 格式化输出整数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> testInteger = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number = %d&quot;</span>, testInteger);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编译以上程序，输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Number = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>在 printf() 函数的引号中使用 “%d” (整型) 来匹配整型变量 testInteger 并输出到屏幕。</p>
<h2 id="f-格式化输出浮点型数据"><a href="#f-格式化输出浮点型数据" class="headerlink" title="%f 格式化输出浮点型数据"></a>%f 格式化输出浮点型数据</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a number: &quot;</span>);</span><br><span class="line">    <span class="comment">// %f 匹配浮点型数据</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value = %f&quot;</span>, f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="getchar-amp-putchar-函数"><a href="#getchar-amp-putchar-函数" class="headerlink" title="getchar() &amp; putchar() 函数"></a>getchar() &amp; putchar() 函数</h2><p><strong>int getchar(void)</strong> 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。</p>
<p><strong>int putchar(int c)</strong> 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。</p>
<p>请看下面的实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> c;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);</span><br><span class="line">   c = getchar( );</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: &quot;</span>);</span><br><span class="line">   <span class="built_in">putchar</span>( c );</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并只会读取一个单一的字符，显示如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob</span><br><span class="line"></span><br><span class="line">You entered: r</span><br></pre></td></tr></table></figure>

<h2 id="gets-amp-puts-函数"><a href="#gets-amp-puts-函数" class="headerlink" title="gets() &amp; puts() 函数"></a>gets() &amp; puts() 函数</h2><p><strong>char *gets(char *s)</strong> 函数从 <strong>stdin</strong> 读取一行到 <strong>s</strong> 所指向的缓冲区，直到一个终止符或 EOF。</p>
<p><strong>int puts(const char *s)</strong> 函数把字符串 s 和一个尾随的换行符写入到 <strong>stdout</strong>。</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);</span><br><span class="line">   gets( str );</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: &quot;</span>);</span><br><span class="line">   <span class="built_in">puts</span>( str );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$./<span class="selector-tag">a</span><span class="selector-class">.out</span></span><br><span class="line">Enter <span class="selector-tag">a</span> value :runoob</span><br><span class="line"></span><br><span class="line">You entered: runoob</span><br></pre></td></tr></table></figure>

<h2 id="scanf-和-printf-函数"><a href="#scanf-和-printf-函数" class="headerlink" title="scanf() 和 printf() 函数"></a>scanf() 和 printf() 函数</h2><p><strong>int scanf(const char *format, …)</strong> 函数从标准输入流 <strong>stdin</strong> 读取输入，并根据提供的 <strong>format</strong> 来浏览输入。</p>
<p><strong>int printf(const char *format, …)</strong> 函数把输出写入到标准输出流 <strong>stdout</strong> ，并根据提供的格式产生输出。</p>
<p><strong>format</strong> 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。如需了解完整的细节，可以查看这些函数的参考手册。现在让我们通过下面这个简单的实例来加深理解：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Enter a value :&quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, str, &amp;i);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;\nYou entered: %s %d &quot;</span>, str, i);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取输入，显示如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$./<span class="selector-tag">a</span><span class="selector-class">.out</span></span><br><span class="line">Enter <span class="selector-tag">a</span> value :runoob <span class="number">123</span></span><br><span class="line"></span><br><span class="line">You entered: runoob <span class="number">123</span> </span><br></pre></td></tr></table></figure>

<p>在这里，应当指出的是，scanf() 期待输入的格式与您给出的 %s 和 %d 相同，这意味着您必须提供有效的输入，比如 “string integer”，如果您提供的是 “string string” 或 “integer integer”，它会被认为是错误的输入。另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 “this is test” 对 scanf() 来说是三个字符串。</p>
<h1 id="C-文件读写"><a href="#C-文件读写" class="headerlink" title="C 文件读写"></a>C 文件读写</h1><p>上一章我们讲解了 C 语言处理的标准输入和输出设备。本章我们将介绍 C 程序员如何创建、打开、关闭文本文件或二进制文件。</p>
<p>一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。本章将讲解文件管理的重要调用。</p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>您可以使用 <strong>fopen( )</strong> 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 <strong>FILE</strong> 的一个对象，类型 <strong>FILE</strong> 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode )</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>filename</strong> 是字符串，用来命名文件，访问模式 <strong>mode</strong> 的值可以是下列值中的一个：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="left">打开一个已有的文本文件，允许读取文件。</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td>
</tr>
<tr>
<td align="left">r+</td>
<td align="left">打开一个文本文件，允许读写文件。</td>
</tr>
<tr>
<td align="left">w+</td>
<td align="left">打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td>
</tr>
<tr>
<td align="left">a+</td>
<td align="left">打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td>
</tr>
</tbody></table>
<p>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;rb&quot;</span>, <span class="string">&quot;wb&quot;</span>, <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;rb+&quot;</span>, <span class="string">&quot;r+b&quot;</span>, <span class="string">&quot;wb+&quot;</span>, <span class="string">&quot;w+b&quot;</span>, <span class="string">&quot;ab+&quot;</span>, <span class="string">&quot;a+b&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">int <span class="meta">fclose</span>( <span class="keyword">FILE</span> <span class="comment">*fp );</span></span><br></pre></td></tr></table></figure>

<p>如果成功关闭文件，<strong>fclose( )</strong> 函数返回零，如果关闭文件时发生错误，函数返回 <strong>EOF</strong>。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 <strong>stdio.h</strong> 中的常量。</p>
<p>C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。</p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>下面是把字符写入到流中的最简单的函数：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputc</span><span class="params">( <span class="type">int</span> c, FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数 <strong>fputc()</strong> 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <strong>EOF</strong>。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *s, FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数 <strong>fputs()</strong> 把字符串 <strong>s</strong> 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 <strong>EOF</strong>。您也可以使用 <strong>int fprintf(FILE *fp,const char *format, …)</strong> 函数把一个字符串写入到文件中。尝试下面的实例：</p>
<blockquote>
<p><strong>注意：</strong>请确保您有可用的 <strong>tmp</strong> 目录，如果不存在该目录，则需要在您的计算机上先创建该目录。</p>
<p><strong>&#x2F;tmp</strong> 一般是 Linux 系统上的临时目录，如果你在 Windows 系统上运行，则需要修改为本地环境中已存在的目录，例如: <strong>C:\tmp</strong>、<strong>D:\tmp</strong>等。</p>
</blockquote>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">   fp = fopen(<span class="string">&quot;/tmp/test.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">   <span class="built_in">fprintf</span>(fp, <span class="string">&quot;This is testing for fprintf...\n&quot;</span>);</span><br><span class="line">   <span class="built_in">fputs</span>(<span class="string">&quot;This is testing for fputs...\n&quot;</span>, fp);</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会在 &#x2F;tmp 目录中创建一个新的文件 <strong>test.txt</strong>，并使用两个不同的函数写入两行。接下来让我们来读取这个文件。</p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>下面是从文件读取单个字符的最简单的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">( FILE * fp )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>fgetc()</strong> 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 <strong>EOF</strong>。下面的函数允许您从流中读取一个字符串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">( <span class="type">char</span> *buf, <span class="type">int</span> n, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>

<p>函数 <strong>fgets()</strong> 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 <strong>buf</strong>，并在最后追加一个 <strong>null</strong> 字符来终止字符串。</p>
<p>如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。您也可以使用 <strong>int fscanf(FILE *fp, const char *format, …)</strong> 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="type">char</span> buff[<span class="number">255</span>];</span><br><span class="line"> </span><br><span class="line">   fp = fopen(<span class="string">&quot;/tmp/test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s&quot;</span>, buff);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;1: %s\n&quot;</span>, buff );</span><br><span class="line"> </span><br><span class="line">   fgets(buff, <span class="number">255</span>, (FILE*)fp);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;2: %s\n&quot;</span>, buff );</span><br><span class="line">   </span><br><span class="line">   fgets(buff, <span class="number">255</span>, (FILE*)fp);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;3: %s\n&quot;</span>, buff );</span><br><span class="line">   fclose(fp);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会读取上一部分创建的文件，产生下列结果：</p>
<figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: This</span><br><span class="line"><span class="number">2</span>: <span class="keyword">is</span> testing for fprintf...</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>: This <span class="keyword">is</span> testing for fputs...</span><br></pre></td></tr></table></figure>

<p>首先，<strong>fscanf()</strong> 方法只读取了 <strong>This</strong>，因为它在后边遇到了一个空格。其次，调用 <strong>fgets()</strong> 读取剩余的部分，直到行尾。最后，调用 <strong>fgets()</strong> 完整地读取第二行。</p>
<h2 id="二进制-I-x2F-O-函数"><a href="#二进制-I-x2F-O-函数" class="headerlink" title="二进制 I&#x2F;O 函数"></a>二进制 I&#x2F;O 函数</h2><p>下面两个函数用于二进制输入和输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size_of_elements, </span></span><br><span class="line"><span class="params">             <span class="type">size_t</span> number_of_elements, FILE *a_file)</span>;</span><br><span class="line">              </span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size_of_elements, </span></span><br><span class="line"><span class="params">             <span class="type">size_t</span> number_of_elements, FILE *a_file)</span>;</span><br></pre></td></tr></table></figure>



<p>这两个函数都是用于存储块的读写 - 通常是数组或结构体。</p>
<h1 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C 预处理器"></a>C 预处理器</h1><p><strong>C 预处理器</strong>不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。</p>
<p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">#define</td>
<td align="left">定义宏</td>
</tr>
<tr>
<td align="left">#include</td>
<td align="left">包含一个源代码文件</td>
</tr>
<tr>
<td align="left">#undef</td>
<td align="left">取消已定义的宏</td>
</tr>
<tr>
<td align="left">#ifdef</td>
<td align="left">如果宏已经定义，则返回真</td>
</tr>
<tr>
<td align="left">#ifndef</td>
<td align="left">如果宏没有定义，则返回真</td>
</tr>
<tr>
<td align="left">#if</td>
<td align="left">如果给定条件为真，则编译下面代码</td>
</tr>
<tr>
<td align="left">#else</td>
<td align="left">#if 的替代方案</td>
</tr>
<tr>
<td align="left">#elif</td>
<td align="left">如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td>
</tr>
<tr>
<td align="left">#endif</td>
<td align="left">结束一个 #if……#else 条件编译块</td>
</tr>
<tr>
<td align="left">#error</td>
<td align="left">当遇到标准错误时，输出错误消息</td>
</tr>
<tr>
<td align="left">#pragma</td>
<td align="left">使用标准化方法，向编译器发布特殊的命令到编译器中</td>
</tr>
</tbody></table>
<h2 id="预处理器实例"><a href="#预处理器实例" class="headerlink" title="预处理器实例"></a>预处理器实例</h2><p>分析下面的实例来理解不同的指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ARRAY_LENGTH 20</span></span><br></pre></td></tr></table></figure>

<p>这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 定义为 20。使用 <em>#define</em> 定义常量来增强可读性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>这些指令告诉 CPP 从<strong>系统库</strong>中获取 stdio.h，并添加文本到当前的源文件中。下一行告诉 CPP 从本地目录中获取 <strong>myheader.h</strong>，并添加内容到当前的源文件中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span>  FILE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_SIZE 42</span></span><br></pre></td></tr></table></figure>

<p>这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MESSAGE</span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> MESSAGE <span class="string">&quot;You wish!&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">   <span class="comment">/* Your debugging statements here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 <em>-DDEBUG</em> 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。</p>
<h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><p>ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。</p>
<table>
<thead>
<tr>
<th align="left">宏</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>DATE</strong></td>
<td align="left">当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。</td>
</tr>
<tr>
<td align="left"><strong>TIME</strong></td>
<td align="left">当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。</td>
</tr>
<tr>
<td align="left"><strong>FILE</strong></td>
<td align="left">这会包含当前文件名，一个字符串常量。</td>
</tr>
<tr>
<td align="left"><strong>LINE</strong></td>
<td align="left">这会包含当前行号，一个十进制常量。</td>
</tr>
<tr>
<td align="left"><strong>STDC</strong></td>
<td align="left">当编译器以 ANSI 标准编译时，则定义为 1。</td>
</tr>
</tbody></table>
<p>让我们来尝试下面的实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;File :%s\n&quot;</span>, __FILE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Date :%s\n&quot;</span>, __DATE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Time :%s\n&quot;</span>, __TIME__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Line :%d\n&quot;</span>, __LINE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ANSI :%d\n&quot;</span>, __STDC__ );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码（在文件 <strong>test.c</strong> 中）被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">File :test.c</span><br><span class="line">Date :Jun <span class="number">2</span> <span class="number">2012</span></span><br><span class="line">Time :<span class="number">03</span>:<span class="number">36</span>:<span class="number">24</span></span><br><span class="line">Line :<span class="number">8</span></span><br><span class="line">ANSI :<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="预处理器运算符"><a href="#预处理器运算符" class="headerlink" title="预处理器运算符"></a>预处理器运算符</h2><p>C 预处理器提供了下列的运算符来帮助您创建宏：</p>
<h3 id="宏延续运算符（-）"><a href="#宏延续运算符（-）" class="headerlink" title="宏延续运算符（\）"></a>宏延续运算符（\）</h3><p>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  message_for(a, b)  \</span></span><br><span class="line"><span class="meta">    printf(#a <span class="string">&quot; and &quot;</span> #b <span class="string">&quot;: We love you!\n&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串常量化运算符（-）"><a href="#字符串常量化运算符（-）" class="headerlink" title="字符串常量化运算符（#）"></a>字符串常量化运算符（#）</h3><p>在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  message_for(a, b)  \</span></span><br><span class="line"><span class="meta">    printf(#a <span class="string">&quot; and &quot;</span> #b <span class="string">&quot;: We love you!\n&quot;</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   message_for(Carole, Debra);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Carole</span> <span class="keyword">and</span> Debra: We love you!</span><br></pre></td></tr></table></figure>

<h3 id="标记粘贴运算符（-）"><a href="#标记粘贴运算符（-）" class="headerlink" title="标记粘贴运算符（##）"></a>标记粘贴运算符（##）</h3><p>宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tokenpaster(n) printf (<span class="string">&quot;token&quot;</span> #n <span class="string">&quot; = %d&quot;</span>, token##n)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> token34 = <span class="number">40</span>;</span><br><span class="line">   </span><br><span class="line">   tokenpaster(<span class="number">34</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">token34 = <span class="number">40</span></span><br></pre></td></tr></table></figure>

<p>这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;token34 = %d&quot;</span>, token34);</span><br></pre></td></tr></table></figure>

<p>这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了<strong>字符串常量化运算符（#）</strong>和<strong>标记粘贴运算符（##）</strong>。</p>
<h3 id="defined-运算符"><a href="#defined-运算符" class="headerlink" title="defined() 运算符"></a>defined() 运算符</h3><p>预处理器 <strong>defined</strong> 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：</p>
<p>实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined (MESSAGE)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> MESSAGE <span class="string">&quot;You wish!&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Here is the message: %s\n&quot;</span>, MESSAGE);  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Here is the message: You wish!</span><br></pre></td></tr></table></figure>

<h3 id="参数化的宏"><a href="#参数化的宏" class="headerlink" title="参数化的宏"></a>参数化的宏</h3><p>CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用宏重写上面的代码，如下：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">define</span> square(<span class="keyword">x</span>) ((<span class="keyword">x</span>) * (<span class="keyword">x</span>))</span><br></pre></td></tr></table></figure>

<p>在使用带有参数的宏之前，必须使用 <strong>#define</strong> 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：</p>
<p>实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Max between 20 and 10 is %d\n&quot;</span>, MAX(<span class="number">10</span>, <span class="number">20</span>));  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Max</span> between <span class="number">20</span> and <span class="number">10</span> is <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h1 id="C-头文件"><a href="#C-头文件" class="headerlink" title="C 头文件"></a>C 头文件</h1><p>头文件是扩展名为 <strong>.h</strong> 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。</p>
<p>在程序中要使用头文件，需要使用 C 预处理指令 <strong>#include</strong> 来引用它。前面我们已经看过 <strong>stdio.h</strong> 头文件，它是编译器自带的头文件。</p>
<p>引用头文件相当于复制头文件的内容，但是我们不会直接在源文件中复制头文件的内容，因为这么做很容易出错，特别在程序是由多个源文件组成的时候。</p>
<p>A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</p>
<h2 id="引用头文件的语法"><a href="#引用头文件的语法" class="headerlink" title="引用头文件的语法"></a>引用头文件的语法</h2><p>使用预处理指令 <strong>#include</strong> 可以引用用户和系统头文件。它的形式有以下两种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;file&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</p>
<h2 id="引用头文件的操作"><a href="#引用头文件的操作" class="headerlink" title="引用头文件的操作"></a>引用头文件的操作</h2><p><strong>#include</strong> 指令会指示 C 预处理器浏览指定的文件作为输入。预处理器的输出包含了已经生成的输出，被引用文件生成的输出以及 <strong>#include</strong> 指令之后的文本输出。例如，如果您有一个头文件 header.h，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">test</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>和一个使用了头文件的主程序 <em>program.c</em>，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">puts</span> (test ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会看到如下的代码信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">test</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">puts</span> (test ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>#include &lt; &gt;</strong> 引用的是编译器的类库路径里面的头文件。</p>
<p><strong>#include “ “</strong> 引用的是你程序目录的相对路径中的头文件，如果在程序目录没有找到引用的头文件则到编译器的类库路径的目录下找该头文件。</p>
<h2 id="只引用一次头文件"><a href="#只引用一次头文件" class="headerlink" title="只引用一次头文件"></a>只引用一次头文件</h2><p>如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEADER_FILE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADER_FILE</span></span><br><span class="line"></span><br><span class="line">the entire header file file</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这种结构就是通常所说的包装器 <strong>#ifndef</strong>。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。</p>
<h2 id="有条件引用"><a href="#有条件引用" class="headerlink" title="有条件引用"></a>有条件引用</h2><p>有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> SYSTEM_1</span></span><br><span class="line">   <span class="meta"># <span class="keyword">include</span> <span class="string">&quot;system_1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SYSTEM_2</span></span><br><span class="line">   <span class="meta"># <span class="keyword">include</span> <span class="string">&quot;system_2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SYSTEM_3</span></span><br><span class="line">   ...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的<strong>有条件引用</strong>。它不是用头文件的名称作为 <strong>#include</strong> 的直接参数，您只需要使用宏名称代替即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYSTEM_H <span class="string">&quot;system_1.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> SYSTEM_H</span></span><br></pre></td></tr></table></figure>

<p>SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 <strong>#include</strong> 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。</p>
<h2 id="多头文件和源文件"><a href="#多头文件和源文件" class="headerlink" title="多头文件和源文件"></a>多头文件和源文件</h2><p>在有多个 <strong>.h</strong> 文件和多个 <strong>.c</strong> 文件的时候，往往我们会用一个 <strong>global.h</strong> 的头文件来包括所有的 <strong>.h</strong> 文件，然后在除 <strong>global.h</strong> 文件外的头文件中 包含 <strong>global.h</strong> 就可以实现所有头文件的包含，同时不会乱。方便在各个文件里面调用其他文件的函数或者变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GLOBAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GLOBAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Config.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="C-强制类型转换"><a href="#C-强制类型转换" class="headerlink" title="C 强制类型转换"></a>C 强制类型转换</h1><p>强制类型转换是把变量从一种类型转换为另一种数据类型。例如，如果您想存储一个 long 类型的值到一个简单的整型中，您需要把 long 类型强制转换为 int 类型。您可以使用<strong>强制类型转换运算符</strong>来把值显式地从一种类型转换为另一种类型，如下所示：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">(type_name) expression</span><br></pre></td></tr></table></figure>

<p>请看下面的实例，使用强制类型转换运算符把一个整数变量除以另一个整数变量，得到一个浮点数：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> sum = <span class="number">17</span>, count = <span class="number">5</span>;</span><br><span class="line">   <span class="type">double</span> mean;</span><br><span class="line"> </span><br><span class="line">   mean = (<span class="type">double</span>) sum / count;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Value of mean : %f\n&quot;</span>, mean );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Value</span> of mean : <span class="number">3</span>.<span class="number">400000</span></span><br></pre></td></tr></table></figure>

<p>这里要注意的是强制类型转换运算符的优先级大于除法，因此 <strong>sum</strong> 的值首先被转换为 <strong>double</strong> 型，然后除以 count，得到一个类型为 double 的值。</p>
<p>类型转换可以是隐式的，由编译器自动执行，也可以是显式的，通过使用<strong>强制类型转换运算符</strong>来指定。在编程时，有需要类型转换的时候都用上强制类型转换运算符，是一种良好的编程习惯。</p>
<h2 id="整数提升"><a href="#整数提升" class="headerlink" title="整数提升"></a>整数提升</h2><p>整数提升是指把小于 <strong>int</strong> 或 <strong>unsigned int</strong> 的整数类型转换为 <strong>int</strong> 或 <strong>unsigned int</strong> 的过程。请看下面的实例，在 int 中添加一个字符：</p>
<p>实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  i = <span class="number">17</span>;</span><br><span class="line">   <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>; <span class="comment">/* ascii 值是 99 */</span></span><br><span class="line">   <span class="type">int</span> sum;</span><br><span class="line"> </span><br><span class="line">   sum = i + c;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Value of sum : %d\n&quot;</span>, sum );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Value <span class="keyword">of</span> sum : 116</span><br></pre></td></tr></table></figure>

<p>在这里，sum 的值为 116，因为编译器进行了整数提升，在执行实际加法运算时，把 ‘c’ 的值转换为对应的 ascii 值。</p>
<h2 id="常用的算术转换"><a href="#常用的算术转换" class="headerlink" title="常用的算术转换"></a>常用的算术转换</h2><p><strong>常用的算术转换</strong>是隐式地把值强制转换为相同的类型。编译器首先执行<strong>整数提升</strong>，如果操作数类型不同，则它们会被转换为下列层次中出现的最高层次的类型：</p>
<p><img data-src="https://www.runoob.com/wp-content/uploads/2014/08/usual_arithmetic_conversion.png" alt="Usual Arithmetic Conversion"></p>
<p>常用的算术转换不适用于赋值运算符、逻辑运算符 &amp;&amp; 和 ||。让我们看看下面的实例来理解这个概念：</p>
<p>实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  i = <span class="number">17</span>;</span><br><span class="line">   <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>; <span class="comment">/* ascii 值是 99 */</span></span><br><span class="line">   <span class="type">float</span> sum;</span><br><span class="line"> </span><br><span class="line">   sum = i + c;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Value of sum : %f\n&quot;</span>, sum );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Value</span> of sum : <span class="number">116</span>.<span class="number">000000</span></span><br></pre></td></tr></table></figure>

<p>在这里，c 首先被转换为整数，但是由于最后的值是 float 型的，所以会应用常用的算术转换，编译器会把 i 和 c 转换为浮点型，并把它们相加得到一个浮点数。</p>
<h1 id="C-错误处理"><a href="#C-错误处理" class="headerlink" title="C 错误处理"></a>C 错误处理</h1><p>C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 <strong>errno</strong>，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。</p>
<p>所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。</p>
<h2 id="errno、perror-和-strerror"><a href="#errno、perror-和-strerror" class="headerlink" title="errno、perror() 和 strerror()"></a>errno、perror() 和 strerror()</h2><p>C 语言提供了 <strong>perror()</strong> 和 <strong>strerror()</strong> 函数来显示与 <strong>errno</strong> 相关的文本消息。</p>
<ul>
<li><strong>perror()</strong> 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。</li>
<li><strong>strerror()</strong> 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。</li>
</ul>
<p>让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 <strong>stderr</strong> 文件流来输出所有的错误。</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> errno ;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   FILE * pf;</span><br><span class="line">   <span class="type">int</span> errnum;</span><br><span class="line">   pf = fopen (<span class="string">&quot;unexist.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      errnum = errno;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;错误号: %d\n&quot;</span>, errno);</span><br><span class="line">      perror(<span class="string">&quot;通过 perror 输出错误&quot;</span>);</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;打开文件错误: %s\n&quot;</span>, strerror( errnum ));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      fclose (pf);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">错误号: <span class="number">2</span></span><br><span class="line">通过 perror 输出错误: <span class="keyword">No</span> such <span class="keyword">file</span> <span class="keyword">or</span> directory</span><br><span class="line">打开文件错误: <span class="keyword">No</span> such <span class="keyword">file</span> <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure>

<h2 id="被零除的错误"><a href="#被零除的错误" class="headerlink" title="被零除的错误"></a>被零除的错误</h2><p>在进行除法运算时，如果不检查除数是否为零，则会导致一个运行时错误。</p>
<p>为了避免这种情况发生，下面的代码在进行除法运算前会先检查除数是否为零：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> dividend = <span class="number">20</span>;</span><br><span class="line">   <span class="type">int</span> divisor = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> quotient;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>( divisor == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;除数为 0 退出运行...\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   quotient = dividend / divisor;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;quotient 变量的值为 : %d\n&quot;</span>, quotient );</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>它会产生下列结果：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">除数为 <span class="number">0</span> 退出运行...</span><br></pre></td></tr></table></figure>

<h2 id="程序退出状态"><a href="#程序退出状态" class="headerlink" title="程序退出状态"></a>程序退出状态</h2><p>通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。</p>
<p>如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。所以，上面的程序可以写成：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> dividend = <span class="number">20</span>;</span><br><span class="line">   <span class="type">int</span> divisor = <span class="number">5</span>;</span><br><span class="line">   <span class="type">int</span> quotient;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>( divisor == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;除数为 0 退出运行...\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   quotient = dividend / divisor;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;quotient 变量的值为: %d\n&quot;</span>, quotient );</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">quotient 变量的值为 : 4</span><br></pre></td></tr></table></figure>

<h1 id="C-可变参数"><a href="#C-可变参数" class="headerlink" title="C 可变参数"></a>C 可变参数</h1><p>有时，您可能会碰到这样的情况，您希望函数带有可变数量的参数，而不是预定义数量的参数。C 语言为这种情况提供了一个解决方案，它允许您定义一个函数，能根据具体的需求接受可变数量的参数。下面的实例演示了这种函数的定义。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">func</span>(<span class="params"><span class="built_in">int</span>, ... </span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">   func(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">   func(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>请注意，函数 <strong>func()</strong> 最后一个参数写成省略号，即三个点号（**…**），省略号之前的那个参数是 <strong>int</strong>，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 <strong>stdarg.h</strong> 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：</p>
<ul>
<li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</li>
<li>在函数定义中创建一个 <strong>va_list</strong> 类型变量，该类型是在 stdarg.h 头文件中定义的。</li>
<li>使用 <strong>int</strong> 参数和 <strong>va_start</strong> 宏来初始化 <strong>va_list</strong> 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。</li>
<li>使用 <strong>va_arg</strong> 宏和 <strong>va_list</strong> 变量来访问参数列表中的每个项。</li>
<li>使用宏 <strong>va_end</strong> 来清理赋予 <strong>va_list</strong> 变量的内存。</li>
</ul>
<p>现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span> num,...)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    va_list valist;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 为 num 个参数初始化 valist */</span></span><br><span class="line">    va_start(valist, num);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 访问所有赋给 valist 的参数 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       sum += va_arg(valist, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清理为 valist 保留的内存 */</span></span><br><span class="line">    va_end(valist);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum/num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Average of 2, 3, 4, 5 = %f\n&quot;</span>, average(<span class="number">4</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Average of 5, 10, 15 = %f\n&quot;</span>, average(<span class="number">3</span>, <span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果。应该指出的是，函数 <strong>average()</strong> 被调用两次，每次第一个参数都是表示被传的可变参数的总数。省略号被用来传递可变数量的参数。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Average</span> of <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> = <span class="number">3</span>.<span class="number">500000</span></span><br><span class="line"><span class="attribute">Average</span> of <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span> = <span class="number">10</span>.<span class="number">000000</span></span><br></pre></td></tr></table></figure>

<h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C 内存管理"></a>C 内存管理</h1><p>本章将讲解 C 中的动态内存管理。C 语言为内存的分配和管理提供了几个函数。这些函数可以在 <strong>&lt;stdlib.h&gt;</strong> 头文件中找到。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>void *calloc(int num, int size);</strong> 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>void free(void *address);</strong> 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>void *malloc(int num);</strong> 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>void *realloc(void *address, int newsize);</strong> 该函数重新分配内存，把内存扩展到 <strong>newsize</strong>。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。</p>
<h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><p>编程时，如果您预先知道数组的大小，那么定义数组时就比较容易。例如，一个存储人名的数组，它最多容纳 100 个字符，所以您可以定义数组，如下所示：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> <span class="keyword">name</span>[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>

<p>但是，如果您预先不知道需要存储的文本长度，例如您想存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">   <span class="type">char</span> *description;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">strcpy</span>(name, <span class="string">&quot;Zara Ali&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 动态分配内存 */</span></span><br><span class="line">   description = (<span class="type">char</span> *)<span class="built_in">malloc</span>( <span class="number">200</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>) );</span><br><span class="line">   <span class="keyword">if</span>( description == <span class="literal">NULL</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error - unable to allocate required memory\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>( description, <span class="string">&quot;Zara ali a DPS student in class 10th&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Name = %s\n&quot;</span>, name );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Description: %s\n&quot;</span>, description );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Name = Zara Ali</span><br><span class="line">Description: Zara ali a DPS student <span class="keyword">in</span> <span class="keyword">class</span> <span class="symbol">10th</span></span><br></pre></td></tr></table></figure>

<p>上面的程序也可以使用 <strong>calloc()</strong> 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">200</span>, <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br></pre></td></tr></table></figure>

<p>当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数组，一旦定义则无法改变大小。</p>
<h2 id="重新调整内存的大小和释放内存"><a href="#重新调整内存的大小和释放内存" class="headerlink" title="重新调整内存的大小和释放内存"></a>重新调整内存的大小和释放内存</h2><p>当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 <strong>free()</strong> 来释放内存。</p>
<p>或者，您可以通过调用函数 <strong>realloc()</strong> 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">   <span class="type">char</span> *description;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">strcpy</span>(name, <span class="string">&quot;Zara Ali&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 动态分配内存 */</span></span><br><span class="line">   description = (<span class="type">char</span> *)<span class="built_in">malloc</span>( <span class="number">30</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>) );</span><br><span class="line">   <span class="keyword">if</span>( description == <span class="literal">NULL</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error - unable to allocate required memory\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>( description, <span class="string">&quot;Zara ali a DPS student.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 假设您想要存储更大的描述信息 */</span></span><br><span class="line">   description = (<span class="type">char</span> *) <span class="built_in">realloc</span>( description, <span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>) );</span><br><span class="line">   <span class="keyword">if</span>( description == <span class="literal">NULL</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error - unable to allocate required memory\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">strcat</span>( description, <span class="string">&quot;She is in class 10th&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Name = %s\n&quot;</span>, name );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Description: %s\n&quot;</span>, description );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用 free() 函数释放内存 */</span></span><br><span class="line">   <span class="built_in">free</span>(description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Name = Zara Ali</span><br><span class="line">Description: Zara ali a DPS student.She is in class <span class="number">10</span>th</span><br></pre></td></tr></table></figure>

<p>您可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。</p>
<h1 id="C-命令行参数"><a href="#C-命令行参数" class="headerlink" title="C 命令行参数"></a>C 命令行参数</h1><p>执行程序时，可以从命令行传值给 C 程序。这些值被称为<strong>命令行参数</strong>，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。</p>
<p>命令行参数是使用 main() 函数参数来处理的，其中，<strong>argc</strong> 是指传入参数的个数，<strong>argv[]</strong> 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span>  </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>( argc == <span class="number">2</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The argument supplied is %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>( argc &gt; <span class="number">2</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Too many arguments supplied.\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;One argument expected.\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用一个参数，编译并执行上面的代码，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$./a.out testing</span><br><span class="line">The argument supplied is testing</span><br></pre></td></tr></table></figure>

<p>使用两个参数，编译并执行上面的代码，它会产生下列结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$./a.out testing1 testing2</span><br><span class="line">Too many arguments supplied.</span><br></pre></td></tr></table></figure>

<p>不传任何参数，编译并执行上面的代码，它会产生下列结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./a.out</span></span><br><span class="line">One argument expected</span><br></pre></td></tr></table></figure>

<p>应当指出的是，<strong>argv[0]</strong> 存储程序的名称，<strong>argv[1]</strong> 是一个指向第一个命令行参数的指针，<em>argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，*<em>argc</em></em> 将被设置为 2。</p>
<p>多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 “” 或单引号 ‘’ 内部。让我们重新编写上面的实例，有一个空间，那么你可以通过这样的观点，把它们放在双引号或单引号””””。让我们重新编写上面的实例，向程序传递一个放置在双引号内部的命令行参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span>  </span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Program name %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>( argc == <span class="number">2</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The argument supplied is %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>( argc &gt; <span class="number">2</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Too many arguments supplied.\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;One argument expected.\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用一个用空格分隔的简单参数，参数括在双引号中，编译并执行上面的代码，它会产生下列结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./a.out <span class="string">&quot;testing1 testing2&quot;</span></span></span><br><span class="line"></span><br><span class="line">Progranm name ./a.out</span><br><span class="line">The argument supplied is testing1 testing2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
</search>
